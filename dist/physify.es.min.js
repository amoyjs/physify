import{Ticker,Sprite,Graphics,Container}from"pixi.js";/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function __rest(o,n){var e={};for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&0>n.indexOf(t)&&(e[t]=o[t]);if(null!=o&&"function"==typeof Object.getOwnPropertySymbols)for(var s=0,t=Object.getOwnPropertySymbols(o);s<t.length;s++)0>n.indexOf(t[s])&&Object.prototype.propertyIsEnumerable.call(o,t[s])&&(e[t[s]]=o[t[s]]);return e}var commonjsGlobal="undefined"==typeof globalThis?"undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window:globalThis;function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs")}function createCommonjsModule(e,t){return t={exports:{}},e(t,t.exports),t.exports}var matter=createCommonjsModule(function(e){/**
* matter-js 0.14.2 by @liabru 2018-06-11
* http://brm.io/matter-js/
* License MIT
*/ /**
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */(function(t){e.exports=t()})(function(){var e=Math.sqrt,t=Math.PI,o=Math.ceil,n=Math.floor,s=Math.max,r=Math.min,a=Math.pow,l=Math.sin,d=Math.cos,p=Math.abs;return function(){function s(l,e,n){function t(d,i){if(!e[d]){if(!l[d]){var r="function"==typeof commonjsRequire&&commonjsRequire;if(!i&&r)return r(d,!0);if(o)return o(d,!0);var c=new Error("Cannot find module '"+d+"'");throw c.code="MODULE_NOT_FOUND",c}var a=e[d]={exports:{}};l[d][0].call(a.exports,function(e){var i=l[d][1][e];return t(i||e)},a,a.exports,s,l,e,n)}return e[d].exports}for(var o="function"==typeof commonjsRequire&&commonjsRequire,r=0;r<n.length;r++)t(n[r]);return t}return s}()({1:[function(e,t){/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/var o={};t.exports=o;var n=e("../geometry/Vertices"),s=e("../geometry/Vector"),r=e("../core/Sleeping"),c=e("../render/Render"),m=e("../core/Common"),y=e("../geometry/Bounds"),g=e("../geometry/Axes");(function(){o._inertiaScale=4,o._nextCollidingGroupId=1,o._nextNonCollidingGroupId=-1,o._nextCategory=1,o.create=function(t){var i={id:m.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:n.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,render:{visible:!0,opacity:1,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0},lineWidth:0}},o=m.extend(i,t);return e(o,t),o},o.nextGroup=function(e){return e?o._nextNonCollidingGroupId--:o._nextCollidingGroupId++},o.nextCategory=function(){return o._nextCategory<<=1,o._nextCategory};/**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */var e=function(e,t){t=t||{},o.set(e,{bounds:e.bounds||y.create(e.vertices),positionPrev:e.positionPrev||s.clone(e.position),anglePrev:e.anglePrev||e.angle,vertices:e.vertices,parts:e.parts||[e],isStatic:e.isStatic,isSleeping:e.isSleeping,parent:e.parent||e}),n.rotate(e.vertices,e.angle,e.position),g.rotate(e.axes,e.angle),y.update(e.bounds,e.vertices,e.velocity),o.set(e,{axes:t.axes||e.axes,area:t.area||e.area,mass:t.mass||e.mass,inertia:t.inertia||e.inertia});// render properties
var i=e.isStatic?"#2e2b44":m.choose(["#006BA6","#0496FF","#FFBC42","#D81159","#8F2D56"]);e.render.fillStyle=e.render.fillStyle||i,e.render.strokeStyle=e.render.strokeStyle||"#000",e.render.sprite.xOffset+=-(e.bounds.min.x-e.position.x)/(e.bounds.max.x-e.bounds.min.x),e.render.sprite.yOffset+=-(e.bounds.min.y-e.position.y)/(e.bounds.max.y-e.bounds.min.y)};/**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */ /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */ /**
     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */ /**
     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */ /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */ /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */ /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */ /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */ /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */ /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */ /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */ /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */ /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     * @param {vector} [point]
     */ /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */ /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */ /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */ /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */o.set=function(e,t,i){for(var n in"string"==typeof t&&(n=t,t={},t[n]=i),t)i=t[n],t.hasOwnProperty(n)&&("isStatic"===n?o.setStatic(e,i):"isSleeping"===n?r.set(e,i):"mass"===n?o.setMass(e,i):"density"===n?o.setDensity(e,i):"inertia"===n?o.setInertia(e,i):"vertices"===n?o.setVertices(e,i):"position"===n?o.setPosition(e,i):"angle"===n?o.setAngle(e,i):"velocity"===n?o.setVelocity(e,i):"angularVelocity"===n?o.setAngularVelocity(e,i):"parts"===n?o.setParts(e,i):e[n]=i)},o.setStatic=function(e,t){for(var o=0,n;o<e.parts.length;o++)n=e.parts[o],n.isStatic=t,t?(n._original={restitution:n.restitution,friction:n.friction,mass:n.mass,inertia:n.inertia,density:n.density,inverseMass:n.inverseMass,inverseInertia:n.inverseInertia},n.restitution=0,n.friction=1,n.mass=n.inertia=n.density=1/0,n.inverseMass=n.inverseInertia=0,n.positionPrev.x=n.position.x,n.positionPrev.y=n.position.y,n.anglePrev=n.angle,n.angularVelocity=0,n.speed=0,n.angularSpeed=0,n.motion=0):n._original&&(n.restitution=n._original.restitution,n.friction=n._original.friction,n.mass=n._original.mass,n.inertia=n._original.inertia,n.density=n._original.density,n.inverseMass=n._original.inverseMass,n.inverseInertia=n._original.inverseInertia,delete n._original)},o.setMass=function(e,t){var i=e.inertia/(e.mass/6);e.inertia=i*(t/6),e.inverseInertia=1/e.inertia,e.mass=t,e.inverseMass=1/e.mass,e.density=e.mass/e.area},o.setDensity=function(e,t){o.setMass(e,t*e.area),e.density=t},o.setInertia=function(e,t){e.inertia=t,e.inverseInertia=1/e.inertia},o.setVertices=function(e,t){e.vertices=t[0].body===e?t:n.create(t,e),e.axes=g.fromVertices(e.vertices),e.area=n.area(e.vertices),o.setMass(e,e.density*e.area);// orient vertices around the centre of mass at origin (0, 0)
var i=n.centre(e.vertices);// update inertia while vertices are at origin (0, 0)
// update geometry
n.translate(e.vertices,i,-1),o.setInertia(e,o._inertiaScale*n.inertia(e.vertices,e.mass)),n.translate(e.vertices,e.position),y.update(e.bounds,e.vertices,e.velocity)},o.setParts=function(e,t,s){var r;// add all the parts, ensuring that the first part is always the parent body
for(t=t.slice(0),e.parts.length=0,e.parts.push(e),e.parent=e,r=0;r<t.length;r++){var a=t[r];a!==e&&(a.parent=e,e.parts.push(a))}if(1!==e.parts.length){// find the convex hull of all parts to set on the parent body
if(s="undefined"==typeof s||s,s){var l=[];for(r=0;r<t.length;r++)l=l.concat(t[r].vertices);n.clockwiseSort(l);var d=n.hull(l),c=n.centre(d);o.setVertices(e,d),n.translate(e.vertices,c)}// sum the properties of all compound parts of the parent body
var p=o._totalProperties(e);e.area=p.area,e.parent=e,e.position.x=p.centre.x,e.position.y=p.centre.y,e.positionPrev.x=p.centre.x,e.positionPrev.y=p.centre.y,o.setMass(e,p.mass),o.setInertia(e,p.inertia),o.setPosition(e,p.centre)}},o.setPosition=function(e,t){var o=s.sub(t,e.position);e.positionPrev.x+=o.x,e.positionPrev.y+=o.y;for(var r=0,a;r<e.parts.length;r++)a=e.parts[r],a.position.x+=o.x,a.position.y+=o.y,n.translate(a.vertices,o),y.update(a.bounds,a.vertices,e.velocity)},o.setAngle=function(e,t){var o=t-e.angle;e.anglePrev+=o;for(var r=0,a;r<e.parts.length;r++)a=e.parts[r],a.angle+=o,n.rotate(a.vertices,o,e.position),g.rotate(a.axes,o),y.update(a.bounds,a.vertices,e.velocity),0<r&&s.rotateAbout(a.position,o,e.position,a.position)},o.setVelocity=function(e,t){e.positionPrev.x=e.position.x-t.x,e.positionPrev.y=e.position.y-t.y,e.velocity.x=t.x,e.velocity.y=t.y,e.speed=s.magnitude(e.velocity)},o.setAngularVelocity=function(e,t){e.anglePrev=e.angle-t,e.angularVelocity=t,e.angularSpeed=p(e.angularVelocity)},o.translate=function(e,t){o.setPosition(e,s.add(e.position,t))},o.rotate=function(e,t,i){if(!i)o.setAngle(e,e.angle+t);else{var n=d(t),s=l(t),r=e.position.x-i.x,a=e.position.y-i.y;o.setPosition(e,{x:i.x+(r*n-a*s),y:i.y+(r*s+a*n)}),o.setAngle(e,e.angle+t)}},o.scale=function(e,t,s,r){var a=0,l=0;r=r||e.position;for(var d=0,c;d<e.parts.length;d++)// scale vertices
// update properties
// update inertia (requires vertices to be at origin)
// scale position
// update bounds
c=e.parts[d],n.scale(c.vertices,t,s,r),c.axes=g.fromVertices(c.vertices),c.area=n.area(c.vertices),o.setMass(c,e.density*c.area),n.translate(c.vertices,{x:-c.position.x,y:-c.position.y}),o.setInertia(c,o._inertiaScale*n.inertia(c.vertices,c.mass)),n.translate(c.vertices,{x:c.position.x,y:c.position.y}),0<d&&(a+=c.area,l+=c.inertia),c.position.x=r.x+(c.position.x-r.x)*t,c.position.y=r.y+(c.position.y-r.y)*s,y.update(c.bounds,c.vertices,e.velocity);// handle parent body
1<e.parts.length&&(e.area=a,!e.isStatic&&(o.setMass(e,e.density*a),o.setInertia(e,l))),e.circleRadius&&(t===s?e.circleRadius*=t:e.circleRadius=null)},o.update=function(e,t,o,r){var l=a(t*o*e.timeScale,2),d=1-e.frictionAir*o*e.timeScale,c=e.position.x-e.positionPrev.x,m=e.position.y-e.positionPrev.y;// from the previous step
e.velocity.x=c*d*r+e.force.x/e.mass*l,e.velocity.y=m*d*r+e.force.y/e.mass*l,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.position.x+=e.velocity.x,e.position.y+=e.velocity.y,e.angularVelocity=(e.angle-e.anglePrev)*d*r+e.torque/e.inertia*l,e.anglePrev=e.angle,e.angle+=e.angularVelocity,e.speed=s.magnitude(e.velocity),e.angularSpeed=p(e.angularVelocity);// transform the body geometry
for(var u=0,x;u<e.parts.length;u++)x=e.parts[u],n.translate(x.vertices,e.velocity),0<u&&(x.position.x+=e.velocity.x,x.position.y+=e.velocity.y),0!==e.angularVelocity&&(n.rotate(x.vertices,e.angularVelocity,e.position),g.rotate(x.axes,e.angularVelocity),0<u&&s.rotateAbout(x.position,e.angularVelocity,e.position,x.position)),y.update(x.bounds,x.vertices,e.velocity)},o.applyForce=function(e,t,i){e.force.x+=i.x,e.force.y+=i.y;var o={x:t.x-e.position.x,y:t.y-e.position.y};e.torque+=o.x*i.y-o.y*i.x},o._totalProperties=function(e){// from equations at:
// https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
// http://output.to/sideway/default.asp?qno=121100087
// sum the properties of all compound parts of the parent body
for(var t={mass:0,area:0,inertia:0,centre:{x:0,y:0}},o=1===e.parts.length?0:1;o<e.parts.length;o++){var n=e.parts[o],r=n.mass===1/0?1:n.mass;t.mass+=r,t.area+=n.area,t.inertia+=n.inertia,t.centre=s.add(t.centre,s.mult(n.position,r))}return t.centre=s.div(t.centre,t.mass),t}})()},{"../core/Common":14,"../core/Sleeping":22,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29,"../render/Render":31}],2:[function(e,t){/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/var o={};t.exports=o;var n=e("../core/Events"),s=e("../core/Common"),r=e("../geometry/Bounds"),a=e("./Body");(function(){/**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */ /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */ /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */ /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */ /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */ /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */ /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */ /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */ /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */ /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */ /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */ /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */ /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */ /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */ /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */ /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */ /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */ /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */ /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */ /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */ /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */ /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */ /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */ /**
     * Returns the union of the bounds of all of the composite's bodies.
     * @method bounds
     * @param {composite} composite The composite.
     * @returns {bounds} The composite bounds.
     */o.create=function(e){return s.extend({id:s.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{}},e)},o.setModified=function(e,t,n,s){if(e.isModified=t,n&&e.parent&&o.setModified(e.parent,t,n,s),s)for(var r=0,a;r<e.composites.length;r++)a=e.composites[r],o.setModified(a,t,n,s)},o.add=function(e,t){var r=[].concat(t);n.trigger(e,"beforeAdd",{object:t});for(var a=0,l;a<r.length;a++)switch(l=r[a],l.type){case"body":// skip adding compound parts
if(l.parent!==l){s.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");break}o.addBody(e,l);break;case"constraint":o.addConstraint(e,l);break;case"composite":o.addComposite(e,l);break;case"mouseConstraint":o.addConstraint(e,l.constraint);}return n.trigger(e,"afterAdd",{object:t}),e},o.remove=function(e,t,s){var r=[].concat(t);n.trigger(e,"beforeRemove",{object:t});for(var a=0,l;a<r.length;a++)switch(l=r[a],l.type){case"body":o.removeBody(e,l,s);break;case"constraint":o.removeConstraint(e,l,s);break;case"composite":o.removeComposite(e,l,s);break;case"mouseConstraint":o.removeConstraint(e,l.constraint);}return n.trigger(e,"afterRemove",{object:t}),e},o.addComposite=function(e,t){return e.composites.push(t),t.parent=e,o.setModified(e,!0,!0,!1),e},o.removeComposite=function(e,t,n){var r=s.indexOf(e.composites,t);if(-1!==r&&(o.removeCompositeAt(e,r),o.setModified(e,!0,!0,!1)),n)for(var a=0;a<e.composites.length;a++)o.removeComposite(e.composites[a],t,!0);return e},o.removeCompositeAt=function(e,t){return e.composites.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addBody=function(e,t){return e.bodies.push(t),o.setModified(e,!0,!0,!1),e},o.removeBody=function(e,t,n){var r=s.indexOf(e.bodies,t);if(-1!==r&&(o.removeBodyAt(e,r),o.setModified(e,!0,!0,!1)),n)for(var a=0;a<e.composites.length;a++)o.removeBody(e.composites[a],t,!0);return e},o.removeBodyAt=function(e,t){return e.bodies.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addConstraint=function(e,t){return e.constraints.push(t),o.setModified(e,!0,!0,!1),e},o.removeConstraint=function(e,t,n){var r=s.indexOf(e.constraints,t);if(-1!==r&&o.removeConstraintAt(e,r),n)for(var a=0;a<e.composites.length;a++)o.removeConstraint(e.composites[a],t,!0);return e},o.removeConstraintAt=function(e,t){return e.constraints.splice(t,1),o.setModified(e,!0,!0,!1),e},o.clear=function(e,t,n){if(n)for(var s=0;s<e.composites.length;s++)o.clear(e.composites[s],t,!0);return t?e.bodies=e.bodies.filter(function(e){return e.isStatic}):e.bodies.length=0,e.constraints.length=0,e.composites.length=0,o.setModified(e,!0,!0,!1),e},o.allBodies=function(e){for(var t=[].concat(e.bodies),n=0;n<e.composites.length;n++)t=t.concat(o.allBodies(e.composites[n]));return t},o.allConstraints=function(e){for(var t=[].concat(e.constraints),n=0;n<e.composites.length;n++)t=t.concat(o.allConstraints(e.composites[n]));return t},o.allComposites=function(e){for(var t=[].concat(e.composites),n=0;n<e.composites.length;n++)t=t.concat(o.allComposites(e.composites[n]));return t},o.get=function(e,t,i){var n,s;return("body"===i?n=o.allBodies(e):"constraint"===i?n=o.allConstraints(e):"composite"===i?n=o.allComposites(e).concat(e):void 0,!n)?null:(s=n.filter(function(e){return e.id.toString()===t.toString()}),0===s.length?null:s[0])},o.move=function(e,t,i){return o.remove(e,t),o.add(i,t),e},o.rebase=function(e){for(var t=o.allBodies(e).concat(o.allConstraints(e)).concat(o.allComposites(e)),n=0;n<t.length;n++)t[n].id=s.nextId();return o.setModified(e,!0,!0,!1),e},o.translate=function(e,t,n){for(var s=n?o.allBodies(e):e.bodies,r=0;r<s.length;r++)a.translate(s[r],t);return o.setModified(e,!0,!0,!1),e},o.rotate=function(e,t,n,s){for(var r=d(t),c=l(t),p=s?o.allBodies(e):e.bodies,m=0;m<p.length;m++){var y=p[m],g=y.position.x-n.x,u=y.position.y-n.y;a.setPosition(y,{x:n.x+(g*r-u*c),y:n.y+(g*c+u*r)}),a.rotate(y,t)}return o.setModified(e,!0,!0,!1),e},o.scale=function(e,t,n,s,r){for(var l=r?o.allBodies(e):e.bodies,d=0;d<l.length;d++){var c=l[d],p=c.position.x-s.x,m=c.position.y-s.y;a.setPosition(c,{x:s.x+p*t,y:s.y+m*n}),a.scale(c,t,n)}return o.setModified(e,!0,!0,!1),e},o.bounds=function(e){for(var t=o.allBodies(e),n=[],s=0,a;s<t.length;s+=1)a=t[s],n.push(a.bounds.min,a.bounds.max);return r.create(n)}})()},{"../core/Common":14,"../core/Events":16,"../geometry/Bounds":26,"./Body":1}],3:[function(e,t){/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/var i={};t.exports=i;var o=e("./Composite"),n=e("../constraint/Constraint"),s=e("../core/Common");(function(){/**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */i.create=function(e){var t=o.create(),i={label:"World",gravity:{x:0,y:1,scale:.001},bounds:{min:{x:-Infinity,y:-Infinity},max:{x:1/0,y:1/0}}};return s.extend(t,i,e)}})()},{"../constraint/Constraint":12,"../core/Common":14,"./Composite":2}],4:[function(e,t){/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/var i={};t.exports=i,function(){/**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */ /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */i.create=function(e){return{id:i.id(e),vertex:e,normalImpulse:0,tangentImpulse:0}},i.id=function(e){return e.body.id+"_"+e.index}}()},{}],5:[function(e,t){/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/ // TODO: speculative contacts
var o={};t.exports=o;var n=e("./SAT"),s=e("./Pair"),r=e("../geometry/Bounds");(function(){/**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */ /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */o.collisions=function(e,t){for(var a=[],l=t.pairs.table,d=0;d<e.length;d++){var c=e[d][0],p=e[d][1];if(!((c.isStatic||c.isSleeping)&&(p.isStatic||p.isSleeping))&&o.canCollide(c.collisionFilter,p.collisionFilter)&&r.overlaps(c.bounds,p.bounds))// mid phase
for(var m=1<c.parts.length?1:0,y;m<c.parts.length;m++){y=c.parts[m];for(var g=1<p.parts.length?1:0,u;g<p.parts.length;g++)if(u=p.parts[g],y===c&&u===p||r.overlaps(y.bounds,u.bounds)){// find a previous collision we could reuse
var x=s.id(y,u),h=l[x],v;v=h&&h.isActive?h.collision:null;// narrow phase
var b=n.collides(y,u,v);b.collided&&a.push(b)}}}return a},o.canCollide=function(e,t){return e.group===t.group&&0!==e.group?0<e.group:0!=(e.mask&t.category)&&0!=(t.mask&e.category)}})()},{"../geometry/Bounds":26,"./Pair":7,"./SAT":11}],6:[function(e,t){/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/var o={};t.exports=o;var a=e("./Pair"),l=e("./Detector"),d=e("../core/Common");(function(){/**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */ /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */ /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */ /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */ /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */ /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */ /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */ /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */ /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */ /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */ /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */ /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */ /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */o.create=function(e){var t={controller:o,detector:l.collisions,buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48};return d.extend(t,e)},o.update=function(e,t,n,s){var r=n.world,a=e.buckets,l=!1,d,c,p,m,y;for(d=0;d<t.length;d++){var g=t[d];if((!g.isSleeping||s)&&!(g.bounds.max.x<r.bounds.min.x||g.bounds.min.x>r.bounds.max.x||g.bounds.max.y<r.bounds.min.y||g.bounds.min.y>r.bounds.max.y))// don't update out of world bodies
{var u=o._getRegion(e,g);// if the body has changed grid region
if(!g.region||u.id!==g.region.id||s){(!g.region||s)&&(g.region=u);var x=o._regionUnion(u,g.region);// update grid buckets affected by region change
// iterate over the union of both regions
for(c=x.startCol;c<=x.endCol;c++)for(p=x.startRow;p<=x.endRow;p++){y=o._getBucketId(c,p),m=a[y];var h=c>=u.startCol&&c<=u.endCol&&p>=u.startRow&&p<=u.endRow,v=c>=g.region.startCol&&c<=g.region.endCol&&p>=g.region.startRow&&p<=g.region.endRow;!h&&v&&v&&m&&o._bucketRemoveBody(e,m,g),(g.region===u||h&&!v||s)&&(!m&&(m=o._createBucket(a,y)),o._bucketAddBody(e,m,g))}// set the new region
g.region=u,l=!0}}}// update pairs list only if pairs changed (i.e. a body changed region)
l&&(e.pairsList=o._createActivePairsList(e))},o.clear=function(e){e.buckets={},e.pairs={},e.pairsList=[]},o._regionUnion=function(e,t){var i=r(e.startCol,t.startCol),n=s(e.endCol,t.endCol),a=r(e.startRow,t.startRow),l=s(e.endRow,t.endRow);return o._createRegion(i,n,a,l)},o._getRegion=function(e,t){var i=t.bounds,s=n(i.min.x/e.bucketWidth),r=n(i.max.x/e.bucketWidth),a=n(i.min.y/e.bucketHeight),l=n(i.max.y/e.bucketHeight);return o._createRegion(s,r,a,l)},o._createRegion=function(e,t,i,o){return{id:e+","+t+","+i+","+o,startCol:e,endCol:t,startRow:i,endRow:o}},o._getBucketId=function(e,t){return"C"+e+"R"+t},o._createBucket=function(e,t){var i=e[t]=[];return i},o._bucketAddBody=function(e,t,o){// add new pairs
for(var n=0,s;n<t.length;n++)if(s=t[n],!(o.id===s.id||o.isStatic&&s.isStatic)){// keep track of the number of buckets the pair exists in
// important for Grid.update to work
var r=a.id(o,s),l=e.pairs[r];l?l[2]+=1:e.pairs[r]=[o,s,1]}// add to bodies (after pairs, otherwise pairs with self)
t.push(o)},o._bucketRemoveBody=function(e,t,o){t.splice(d.indexOf(t,o),1);// update pair counts
for(var n=0;n<t.length;n++){// keep track of the number of buckets the pair exists in
// important for _createActivePairsList to work
var s=t[n],r=a.id(o,s),l=e.pairs[r];l&&(l[2]-=1)}},o._createActivePairsList=function(e){var t=[],i,o;// grid.pairs is used as a hashmap
i=d.keys(e.pairs);// iterate over grid.pairs
for(var n=0;n<i.length;n++)o=e.pairs[i[n]],0<o[2]?t.push(o):delete e.pairs[i[n]];return t}})()},{"../core/Common":14,"./Detector":5,"./Pair":7}],7:[function(e,t){/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/var o={};t.exports=o;var n=e("./Contact");(function(){/**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */ /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */ /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */ /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */o.create=function(e,t){var i=e.bodyA,n=e.bodyB,a=e.parentA,l=e.parentB,d={id:o.id(i,n),bodyA:i,bodyB:n,contacts:{},activeContacts:[],separation:0,isActive:!0,isSensor:i.isSensor||n.isSensor,timeCreated:t,timeUpdated:t,inverseMass:a.inverseMass+l.inverseMass,friction:r(a.friction,l.friction),frictionStatic:s(a.frictionStatic,l.frictionStatic),restitution:s(a.restitution,l.restitution),slop:s(a.slop,l.slop)};return o.update(d,e,t),d},o.update=function(e,t,a){var l=e.contacts,d=t.supports,c=e.activeContacts,p=t.parentA,m=t.parentB;if(e.collision=t,e.inverseMass=p.inverseMass+m.inverseMass,e.friction=r(p.friction,m.friction),e.frictionStatic=s(p.frictionStatic,m.frictionStatic),e.restitution=s(p.restitution,m.restitution),e.slop=s(p.slop,m.slop),c.length=0,t.collided){for(var y=0;y<d.length;y++){var g=d[y],u=n.id(g),x=l[u];x?c.push(x):c.push(l[u]=n.create(g))}e.separation=t.depth,o.setActive(e,!0,a)}else!0===e.isActive&&o.setActive(e,!1,a)},o.setActive=function(e,t,i){t?(e.isActive=!0,e.timeUpdated=i):(e.isActive=!1,e.activeContacts.length=0)},o.id=function(e,t){return e.id<t.id?"A"+e.id+"B"+t.id:"A"+t.id+"B"+e.id}})()},{"./Contact":4}],8:[function(e,t){/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/var o={};t.exports=o;var n=e("./Pair"),s=e("../core/Common");(function(){/**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */ /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */ /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */ /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */o._pairMaxIdleLife=1e3,o.create=function(e){return s.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},e)},o.update=function(e,t,o){var r=e.list,a=e.table,l=e.collisionStart,d=e.collisionEnd,c=e.collisionActive,p=[],m,y,g,u;// clear collision state arrays, but maintain old reference
for(l.length=0,d.length=0,c.length=0,u=0;u<t.length;u++)m=t[u],m.collided&&(y=n.id(m.bodyA,m.bodyB),p.push(y),g=a[y],g?(g.isActive?c.push(g):l.push(g),n.update(g,m,o)):(g=n.create(m,o),a[y]=g,l.push(g),r.push(g)));// deactivate previously active pairs that are now inactive
for(u=0;u<r.length;u++)g=r[u],g.isActive&&-1===s.indexOf(p,g.id)&&(n.setActive(g,!1,o),d.push(g))},o.removeOld=function(e,t){var n=e.list,s=e.table,r=[],a,l,d,c;for(c=0;c<n.length;c++){// never remove sleeping pairs
if(a=n[c],l=a.collision,l.bodyA.isSleeping||l.bodyB.isSleeping){a.timeUpdated=t;continue}// if pair is inactive for too long, mark it to be removed
t-a.timeUpdated>o._pairMaxIdleLife&&r.push(c)}// remove marked pairs
for(c=0;c<r.length;c++)d=r[c]-c,a=n[d],delete s[a.id],n.splice(d,1)},o.clear=function(e){return e.table={},e.list.length=0,e.collisionStart.length=0,e.collisionActive.length=0,e.collisionEnd.length=0,e}})()},{"../core/Common":14,"./Pair":7}],9:[function(e,t){/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/var o={};t.exports=o;var n=e("../geometry/Vector"),s=e("./SAT"),r=e("../geometry/Bounds"),a=e("../factory/Bodies"),l=e("../geometry/Vertices");(function(){/**
     * Returns a list of collisions between `body` and `bodies`.
     * @method collides
     * @param {body} body
     * @param {body[]} bodies
     * @return {object[]} Collisions
     */ /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */ /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */ /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */o.collides=function(e,t){for(var o=[],n=0,a;n<t.length;n++)if(a=t[n],r.overlaps(a.bounds,e.bounds))for(var l=1===a.parts.length?0:1,d;l<a.parts.length;l++)if(d=a.parts[l],r.overlaps(d.bounds,e.bounds)){var c=s.collides(d,e);if(c.collided){o.push(c);break}}return o},o.ray=function(e,t,s,r){r=r||1e-100;for(var l=n.angle(t,s),d=n.magnitude(n.sub(t,s)),c=.5*(s.x+t.x),p=.5*(s.y+t.y),m=a.rectangle(c,p,d,r,{angle:l}),y=o.collides(m,e),g=0,u;g<y.length;g+=1)u=y[g],u.body=u.bodyB=u.bodyA;return y},o.region=function(e,t,o){for(var n=[],s=0;s<e.length;s++){var a=e[s],l=r.overlaps(a.bounds,t);(l&&!o||!l&&o)&&n.push(a)}return n},o.point=function(e,t){for(var o=[],n=0,s;n<e.length;n++)if(s=e[n],r.contains(s.bounds,t))for(var a=1===s.parts.length?0:1,d;a<s.parts.length;a++)if(d=s.parts[a],r.contains(d.bounds,t)&&l.contains(d.vertices,t)){o.push(s);break}return o}})()},{"../factory/Bodies":23,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29,"./SAT":11}],10:[function(e,t){/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/var o={};t.exports=o;var n=e("../geometry/Vertices"),s=e("../geometry/Vector"),a=e("../core/Common"),l=e("../geometry/Bounds");(function(){/**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */ /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */ /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */ /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */ /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */o._restingThresh=4,o._restingThreshTangent=6,o._positionDampen=.9,o._positionWarming=.8,o._frictionNormalMultiplier=5,o.preSolvePosition=function(e){var t,o,n;// find total contacts on each body
for(t=0;t<e.length;t++)o=e[t],o.isActive&&(n=o.activeContacts.length,o.collision.parentA.totalContacts+=n,o.collision.parentB.totalContacts+=n)},o.solvePosition=function(e,t){var n=s._temp[0],r=s._temp[1],a=s._temp[2],l=s._temp[3],d,c,p,m,y,g,u,x,h;// find impulses required to resolve penetration
for(d=0;d<e.length;d++)c=e[d],!c.isActive||c.isSensor||(p=c.collision,m=p.parentA,y=p.parentB,g=p.normal,u=s.sub(s.add(y.positionImpulse,y.position,n),s.add(m.positionImpulse,s.sub(y.position,p.penetration,r),a),l),c.separation=s.dot(g,u));for(d=0;d<e.length;d++)c=e[d],!c.isActive||c.isSensor||(p=c.collision,m=p.parentA,y=p.parentB,g=p.normal,h=(c.separation-c.slop)*t,(m.isStatic||y.isStatic)&&(h*=2),!(m.isStatic||m.isSleeping)&&(x=o._positionDampen/m.totalContacts,m.positionImpulse.x+=g.x*h*x,m.positionImpulse.y+=g.y*h*x),!(y.isStatic||y.isSleeping)&&(x=o._positionDampen/y.totalContacts,y.positionImpulse.x-=g.x*h*x,y.positionImpulse.y-=g.y*h*x))},o.postSolvePosition=function(e){for(var t=0,r;t<e.length;t++)if(r=e[t],r.totalContacts=0,0!==r.positionImpulse.x||0!==r.positionImpulse.y){// update body geometry
for(var a=0,d;a<r.parts.length;a++)d=r.parts[a],n.translate(d.vertices,r.positionImpulse),l.update(d.bounds,d.vertices,r.velocity),d.position.x+=r.positionImpulse.x,d.position.y+=r.positionImpulse.y;// move the body without changing velocity
r.positionPrev.x+=r.positionImpulse.x,r.positionPrev.y+=r.positionImpulse.y,0>s.dot(r.positionImpulse,r.velocity)?(r.positionImpulse.x=0,r.positionImpulse.y=0):(r.positionImpulse.x*=o._positionWarming,r.positionImpulse.y*=o._positionWarming)}},o.preSolveVelocity=function(e){var t=s._temp[0],o=s._temp[1],n,r,a,l,d,c,p,m,y,g,u,x,h,v;for(n=0;n<e.length;n++)if(a=e[n],a.isActive&&!a.isSensor)// resolve each contact
for(l=a.activeContacts,d=a.collision,c=d.parentA,p=d.parentB,m=d.normal,y=d.tangent,r=0;r<l.length;r++)g=l[r],u=g.vertex,x=g.normalImpulse,h=g.tangentImpulse,(0!==x||0!==h)&&(t.x=m.x*x+y.x*h,t.y=m.y*x+y.y*h,!(c.isStatic||c.isSleeping)&&(v=s.sub(u,c.position,o),c.positionPrev.x+=t.x*c.inverseMass,c.positionPrev.y+=t.y*c.inverseMass,c.anglePrev+=s.cross(v,t)*c.inverseInertia),!(p.isStatic||p.isSleeping)&&(v=s.sub(u,p.position,o),p.positionPrev.x-=t.x*p.inverseMass,p.positionPrev.y-=t.y*p.inverseMass,p.anglePrev-=s.cross(v,t)*p.inverseInertia))},o.solveVelocity=function(e,t){for(var n=t*t,l=s._temp[0],d=s._temp[1],c=s._temp[2],m=s._temp[3],y=s._temp[4],g=s._temp[5],u=0,x;u<e.length;u++)if(x=e[u],x.isActive&&!x.isSensor){var h=x.collision,v=h.parentA,b=h.parentB,f=h.normal,S=h.tangent,C=x.activeContacts,w=1/C.length;// update body velocities
v.velocity.x=v.position.x-v.positionPrev.x,v.velocity.y=v.position.y-v.positionPrev.y,b.velocity.x=b.position.x-b.positionPrev.x,b.velocity.y=b.position.y-b.positionPrev.y,v.angularVelocity=v.angle-v.anglePrev,b.angularVelocity=b.angle-b.anglePrev;// resolve each contact
for(var A=0;A<C.length;A++){var P=C[A],B=P.vertex,I=s.sub(B,v.position,d),k=s.sub(B,b.position,c),_=s.add(v.velocity,s.mult(s.perp(I),v.angularVelocity),m),T=s.add(b.velocity,s.mult(s.perp(k),b.angularVelocity),y),R=s.sub(_,T,g),M=s.dot(f,R),V=s.dot(S,R),E=p(V),F=a.sign(V),L=(1+x.restitution)*M,O=a.clamp(x.separation+M,0,1)*o._frictionNormalMultiplier,W=V,q=1/0;E>x.friction*x.frictionStatic*O*n&&(q=E,W=a.clamp(x.friction*F*n,-q,q));// modify impulses accounting for mass, inertia and offset
var D=s.cross(I,f),G=s.cross(k,f),N=w/(v.inverseMass+b.inverseMass+v.inverseInertia*D*D+b.inverseInertia*G*G);// handle high velocity and resting collisions separately
if(L*=N,W*=N,0>M&&M*M>o._restingThresh*n)P.normalImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// impulse constraint tends to 0
var U=P.normalImpulse;P.normalImpulse=r(P.normalImpulse+L,0),L=P.normalImpulse-U}// handle high velocity and resting collisions separately
if(V*V>o._restingThreshTangent*n)P.tangentImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// tangent impulse tends to -tangentSpeed or +tangentSpeed
var H=P.tangentImpulse;P.tangentImpulse=a.clamp(P.tangentImpulse+W,-q,q),W=P.tangentImpulse-H}// total impulse from contact
l.x=f.x*L+S.x*W,l.y=f.y*L+S.y*W,v.isStatic||v.isSleeping||(v.positionPrev.x+=l.x*v.inverseMass,v.positionPrev.y+=l.y*v.inverseMass,v.anglePrev+=s.cross(I,l)*v.inverseInertia),b.isStatic||b.isSleeping||(b.positionPrev.x-=l.x*b.inverseMass,b.positionPrev.y-=l.y*b.inverseMass,b.anglePrev-=s.cross(k,l)*b.inverseInertia)}}}})()},{"../core/Common":14,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],11:[function(e,t){/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/ // TODO: true circles and curves
var o={};t.exports=o;var n=e("../geometry/Vertices"),s=e("../geometry/Vector");(function(){var e=Number.MAX_VALUE;/**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */ /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */ /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */ /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */o.collides=function(e,t,i){var r=!1,a,l,d,c;if(i){// estimate total motion
var p=e.parent,m=t.parent,y=p.speed*p.speed+p.angularSpeed*p.angularSpeed+m.speed*m.speed+m.angularSpeed*m.angularSpeed;// we may be able to (partially) reuse collision result 
// but only safe if collision was resting
r=i&&i.collided&&.2>y,c=i}else c={collided:!1,bodyA:e,bodyB:t};if(i&&r){// if we can reuse the collision result
// we only need to test the previously found axis
var g=c.axisBody,u=g===e?t:e,x=[g.axes[i.axisNumber]];if(d=o._overlapAxes(g.vertices,u.vertices,x),c.reused=!0,0>=d.overlap)return c.collided=!1,c}else{if(a=o._overlapAxes(e.vertices,t.vertices,e.axes),0>=a.overlap)return c.collided=!1,c;if(l=o._overlapAxes(t.vertices,e.vertices,t.axes),0>=l.overlap)return c.collided=!1,c;a.overlap<l.overlap?(d=a,c.axisBody=e):(d=l,c.axisBody=t),c.axisNumber=d.axisNumber}c.bodyA=e.id<t.id?e:t,c.bodyB=e.id<t.id?t:e,c.collided=!0,c.depth=d.overlap,c.parentA=c.bodyA.parent,c.parentB=c.bodyB.parent,e=c.bodyA,t=c.bodyB,c.normal=0>s.dot(d.axis,s.sub(t.position,e.position))?{x:d.axis.x,y:d.axis.y}:{x:-d.axis.x,y:-d.axis.y},c.tangent=s.perp(c.normal),c.penetration=c.penetration||{},c.penetration.x=c.normal.x*c.depth,c.penetration.y=c.normal.y*c.depth;// find support points, there is always either exactly one or two
var h=o._findSupports(e,t,c.normal),v=[];// find the supports from bodyB that are inside bodyA
// find the supports from bodyA that are inside bodyB
if(n.contains(e.vertices,h[0])&&v.push(h[0]),n.contains(e.vertices,h[1])&&v.push(h[1]),2>v.length){var b=o._findSupports(t,e,s.neg(c.normal));n.contains(t.vertices,b[0])&&v.push(b[0]),2>v.length&&n.contains(t.vertices,b[1])&&v.push(b[1])}// account for the edge case of overlapping but no vertex containment
return 1>v.length&&(v=[h[0]]),c.supports=v,c},o._overlapAxes=function(t,n,a){for(var l=s._temp[0],d=s._temp[1],c={overlap:e},p=0,m,y;p<a.length;p++){if(y=a[p],o._projectToAxis(l,t,y),o._projectToAxis(d,n,y),m=r(l.max-d.min,d.max-l.min),0>=m)return c.overlap=m,c;m<c.overlap&&(c.overlap=m,c.axis=y,c.axisNumber=p)}return c},o._projectToAxis=function(e,t,o){for(var n=s.dot(t[0],o),r=n,a=1,l;a<t.length;a+=1)l=s.dot(t[a],o),l>r?r=l:l<n&&(n=l);e.min=n,e.max=r},o._findSupports=function(t,o,n){// find closest vertex on bodyB
for(var r=e,a=s._temp[0],l=o.vertices,d=t.position,c=0,p,m,y,g;c<l.length;c++)m=l[c],a.x=m.x-d.x,a.y=m.y-d.y,p=-s.dot(n,a),p<r&&(r=p,y=m);// find next closest vertex using the two connected to it
var u=0<=y.index-1?y.index-1:l.length-1;m=l[u],a.x=m.x-d.x,a.y=m.y-d.y,r=-s.dot(n,a),g=m;var x=(y.index+1)%l.length;return m=l[x],a.x=m.x-d.x,a.y=m.y-d.y,p=-s.dot(n,a),p<r&&(g=m),[y,g]}})()},{"../geometry/Vector":28,"../geometry/Vertices":29}],12:[function(e,t){/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/var o={};t.exports=o;var n=e("../geometry/Vertices"),s=e("../geometry/Vector"),r=e("../core/Sleeping"),a=e("../geometry/Bounds"),l=e("../geometry/Axes"),d=e("../core/Common");(function(){/**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
     * For compound bodies, constraints must be applied to the parent body (not one of its parts).
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */ /**
     * Prepares for solving by constraint warming.
     * @private
     * @method preSolveAll
     * @param {body[]} bodies
     */ /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */ /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */ /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */o._warming=.4,o._torqueDampen=1,o._minLength=1e-6,o.create=function(e){var t=e;// if bodies defined but no points, use body centre
t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0}),t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});// calculate static length using initial world space points
var i=t.bodyA?s.add(t.bodyA.position,t.pointA):t.pointA,o=t.bodyB?s.add(t.bodyB.position,t.pointB):t.pointB,n=s.magnitude(s.sub(i,o));t.length="undefined"==typeof t.length?n:t.length,t.id=t.id||d.nextId(),t.label=t.label||"Constraint",t.type="constraint",t.stiffness=t.stiffness||(0<t.length?1:.7),t.damping=t.damping||0,t.angularStiffness=t.angularStiffness||0,t.angleA=t.bodyA?t.bodyA.angle:t.angleA,t.angleB=t.bodyB?t.bodyB.angle:t.angleB,t.plugin={};// render
var r={visible:!0,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:!0};return 0===t.length&&.1<t.stiffness?(r.type="pin",r.anchors=!1):.9>t.stiffness&&(r.type="spring"),t.render=d.extend(r,t.render),t},o.preSolveAll=function(e){for(var t=0;t<e.length;t+=1){var o=e[t],n=o.constraintImpulse;o.isStatic||0===n.x&&0===n.y&&0===n.angle||(o.position.x+=n.x,o.position.y+=n.y,o.angle+=n.angle)}},o.solveAll=function(e,t){// Solve fixed constraints first.
for(var n=0;n<e.length;n+=1){var s=e[n],r=!s.bodyA||s.bodyA&&s.bodyA.isStatic,a=!s.bodyB||s.bodyB&&s.bodyB.isStatic;(r||a)&&o.solve(e[n],t)}// Solve free constraints last.
for(n=0;n<e.length;n+=1)s=e[n],r=!s.bodyA||s.bodyA&&s.bodyA.isStatic,a=!s.bodyB||s.bodyB&&s.bodyB.isStatic,r||a||o.solve(e[n],t)},o.solve=function(e,t){var i=e.bodyA,n=e.bodyB,r=e.pointA,a=e.pointB;if(i||n){i&&!i.isStatic&&(s.rotate(r,i.angle-e.angleA,r),e.angleA=i.angle),n&&!n.isStatic&&(s.rotate(a,n.angle-e.angleB,a),e.angleB=n.angle);var l=r,d=a;if(i&&(l=s.add(i.position,r)),n&&(d=s.add(n.position,a)),l&&d){var c=s.sub(l,d),p=s.magnitude(c);// prevent singularity
p<o._minLength&&(p=o._minLength);// solve distance constraint with Gauss-Siedel method
var m=(p-e.length)/p,y=1>e.stiffness?e.stiffness*t:e.stiffness,g=s.mult(c,m*y),u=(i?i.inverseMass:0)+(n?n.inverseMass:0),x=(i?i.inverseInertia:0)+(n?n.inverseInertia:0),h=u+x,v,b,f,S,C;if(e.damping){var w=s.create();f=s.div(c,p),C=s.sub(n&&s.sub(n.position,n.positionPrev)||w,i&&s.sub(i.position,i.positionPrev)||w),S=s.dot(f,C)}i&&!i.isStatic&&(b=i.inverseMass/u,i.constraintImpulse.x-=g.x*b,i.constraintImpulse.y-=g.y*b,i.position.x-=g.x*b,i.position.y-=g.y*b,e.damping&&(i.positionPrev.x-=e.damping*f.x*S*b,i.positionPrev.y-=e.damping*f.y*S*b),v=s.cross(r,g)/h*o._torqueDampen*i.inverseInertia*(1-e.angularStiffness),i.constraintImpulse.angle-=v,i.angle-=v),n&&!n.isStatic&&(b=n.inverseMass/u,n.constraintImpulse.x+=g.x*b,n.constraintImpulse.y+=g.y*b,n.position.x+=g.x*b,n.position.y+=g.y*b,e.damping&&(n.positionPrev.x+=e.damping*f.x*S*b,n.positionPrev.y+=e.damping*f.y*S*b),v=s.cross(a,g)/h*o._torqueDampen*n.inverseInertia*(1-e.angularStiffness),n.constraintImpulse.angle+=v,n.angle+=v)}}// update reference angle
},o.postSolveAll=function(e){for(var t=0;t<e.length;t++){var d=e[t],c=d.constraintImpulse;if(!(d.isStatic||0===c.x&&0===c.y&&0===c.angle)){r.set(d,!1);// update geometry and reset
for(var p=0,m;p<d.parts.length;p++)m=d.parts[p],n.translate(m.vertices,c),0<p&&(m.position.x+=c.x,m.position.y+=c.y),0!==c.angle&&(n.rotate(m.vertices,c.angle,d.position),l.rotate(m.axes,c.angle),0<p&&s.rotateAbout(m.position,c.angle,d.position,m.position)),a.update(m.bounds,m.vertices,d.velocity);// dampen the cached impulse for warming next step
c.angle*=o._warming,c.x*=o._warming,c.y*=o._warming}}}})()},{"../core/Common":14,"../core/Sleeping":22,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],13:[function(e,t){/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/var i={};t.exports=i;var o=e("../geometry/Vertices"),n=e("../core/Sleeping"),s=e("../core/Mouse"),r=e("../core/Events"),a=e("../collision/Detector"),l=e("./Constraint"),d=e("../body/Composite"),c=e("../core/Common"),p=e("../geometry/Bounds");(function(){/**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */ /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */ /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */i.create=function(e,t){var o=(e?e.mouse:null)||(t?t.mouse:null);o||(e&&e.render&&e.render.canvas?o=s.create(e.render.canvas):t&&t.element?o=s.create(t.element):(o=s.create(),c.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));var n=l.create({label:"Mouse Constraint",pointA:o.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}}),a={type:"mouseConstraint",mouse:o,element:null,body:null,constraint:n,collisionFilter:{category:1,mask:4294967295,group:0}},p=c.extend(a,t);return r.on(e,"beforeUpdate",function(){var t=d.allBodies(e.world);i.update(p,t),i._triggerEvents(p)}),p},i.update=function(e,t){var s=e.mouse,l=e.constraint,d=e.body;if(!(0===s.button))l.bodyB=e.body=null,l.pointB=null,d&&r.trigger(e,"enddrag",{mouse:s,body:d});else if(!l.bodyB){for(var c=0;c<t.length;c++)if(d=t[c],p.contains(d.bounds,s.position)&&a.canCollide(d.collisionFilter,e.collisionFilter))for(var m=1<d.parts.length?1:0,y;m<d.parts.length;m++)if(y=d.parts[m],o.contains(y.vertices,s.position)){l.pointA=s.position,l.bodyB=e.body=d,l.pointB={x:s.position.x-d.position.x,y:s.position.y-d.position.y},l.angleB=d.angle,n.set(d,!1),r.trigger(e,"startdrag",{mouse:s,body:d});break}}else n.set(l.bodyB,!1),l.pointA=s.position},i._triggerEvents=function(e){var t=e.mouse,i=t.sourceEvents;// reset the mouse state ready for the next step
i.mousemove&&r.trigger(e,"mousemove",{mouse:t}),i.mousedown&&r.trigger(e,"mousedown",{mouse:t}),i.mouseup&&r.trigger(e,"mouseup",{mouse:t}),s.clearSourceEvents(t)}})()},{"../body/Composite":2,"../collision/Detector":5,"../core/Common":14,"../core/Events":16,"../core/Mouse":19,"../core/Sleeping":22,"../geometry/Bounds":26,"../geometry/Vertices":29,"./Constraint":12}],14:[function(e,t){(function(i){/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/var o={};t.exports=o,function(){o._nextId=0,o._seed=0,o._nowStartTime=+new Date,o.extend=function(e,t){var n,s;"boolean"==typeof t?(n=2,s=t):(n=1,s=!0);for(var r=n,a;r<arguments.length;r++)if(a=arguments[r],a)for(var l in a)s&&a[l]&&a[l].constructor===Object?e[l]&&e[l].constructor!==Object?e[l]=a[l]:(e[l]=e[l]||{},o.extend(e[l],s,a[l])):e[l]=a[l];return e},o.clone=function(e,t){return o.extend({},t,e)},o.keys=function(e){if(Object.keys)return Object.keys(e);// avoid hasOwnProperty for performance
var t=[];for(var i in e)t.push(i);return t},o.values=function(e){var t=[];if(Object.keys){for(var o=Object.keys(e),n=0;n<o.length;n++)t.push(e[o[n]]);return t}// avoid hasOwnProperty for performance
for(var s in e)t.push(e[s]);return t},o.get=function(e,t,o,n){t=t.split(".").slice(o,n);for(var s=0;s<t.length;s+=1)e=e[t[s]];return e},o.set=function(e,t,i,n,s){var r=t.split(".").slice(n,s);return o.get(e,t,0,-1)[r[r.length-1]]=i,i},o.shuffle=function(e){for(var t=e.length-1;0<t;t--){var s=n(o.random()*(t+1)),r=e[t];e[t]=e[s],e[s]=r}return e},o.choose=function(e){return e[n(o.random()*e.length)]},o.isElement=function(e){return"undefined"==typeof HTMLElement?!!(e&&e.nodeType&&e.nodeName):e instanceof HTMLElement},o.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)},o.isFunction=function(e){return"function"==typeof e},o.isPlainObject=function(e){return"object"==typeof e&&e.constructor===Object},o.isString=function(e){return"[object String]"===toString.call(e)},o.clamp=function(e,t,i){return e<t?t:e>i?i:e},o.sign=function(e){return 0>e?-1:1},o.now=function(){if(window.performance){if(window.performance.now)return window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return new Date-o._nowStartTime},o.random=function(e,i){return e="undefined"==typeof e?0:e,i="undefined"==typeof i?1:i,e+t()*(i-e)};var t=function(){return o._seed=(9301*o._seed+49297)%233280,o._seed/233280};/**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */ /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */ /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */ /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */ /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */ /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */ /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */ /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */ /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */ /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */ /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */ /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */ /**
     * Used to require external libraries outside of the bundle.
     * It first looks for the `globalName` on the environment's global namespace.
     * If the global is not found, it will fall back to using the standard `require` using the `moduleName`.
     * @private
     * @method _requireGlobal
     * @param {string} globalName The global module name
     * @param {string} moduleName The fallback CommonJS module name
     * @return {} The loaded module
     */o.colorToNumber=function(e){return e=e.replace("#",""),3==e.length&&(e=e.charAt(0)+e.charAt(0)+e.charAt(1)+e.charAt(1)+e.charAt(2)+e.charAt(2)),parseInt(e,16)},o.logLevel=1,o.log=function(){console&&0<o.logLevel&&3>=o.logLevel&&console.log.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},o.info=function(){console&&0<o.logLevel&&2>=o.logLevel&&console.info.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},o.warn=function(){console&&0<o.logLevel&&3>=o.logLevel&&console.warn.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},o.nextId=function(){return o._nextId++},o.indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var o=0;o<e.length;o++)if(e[o]===t)return o;return-1},o.map=function(e,t){if(e.map)return e.map(t);for(var o=[],n=0;n<e.length;n+=1)o.push(t(e[n]));return o},o.topologicalSort=function(e){// https://github.com/mgechev/javascript-algorithms
// Copyright (c) Minko Gechev (MIT license)
// Modifications: tidy formatting and naming
var t=[],i=[],n=[];for(var s in e)i[s]||n[s]||o._topologicalSort(s,i,n,e,t);return t},o._topologicalSort=function(e,t,n,s,r){var a=s[e]||[];n[e]=!0;for(var l=0,d;l<a.length;l+=1)(d=a[l],!n[d])&&(t[d]||o._topologicalSort(d,t,n,s,r));n[e]=!1,t[e]=!0,r.push(e)},o.chain=function(){for(var e=[],t=0,o;t<arguments.length;t+=1)o=arguments[t],o._chained?e.push.apply(e,o._chained):e.push(o);var n=function(){// https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
for(var t=Array(arguments.length),o=0,n=arguments.length,s;o<n;o++)t[o]=arguments[o];for(o=0;o<e.length;o+=1){var r=e[o].apply(s,t);"undefined"!=typeof r&&(s=r)}return s};return n._chained=e,n},o.chainPathBefore=function(e,t,i){return o.set(e,t,o.chain(i,o.get(e,t)))},o.chainPathAfter=function(e,t,i){return o.set(e,t,o.chain(o.get(e,t),i))},o._requireGlobal=function(t,o){var n="undefined"==typeof window?"undefined"==typeof i?null:i[t]:window[t];return n||e(o)}}()}).call(this,"undefined"==typeof commonjsGlobal?"undefined"==typeof self?"undefined"==typeof window?{}:window:self:commonjsGlobal)},{}],15:[function(e,t){/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/var o={};t.exports=o;var n=e("../body/World"),s=e("./Sleeping"),r=e("../collision/Resolver"),a=e("../render/Render"),l=e("../collision/Pairs"),d=e("./Metrics"),c=e("../collision/Grid"),p=e("./Events"),m=e("../body/Composite"),y=e("../constraint/Constraint"),g=e("./Common"),u=e("../body/Body");(function(){/**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */ /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */ /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */ /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */ /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method _bodiesClearForces
     * @private
     * @param {body[]} bodies
     */ /**
     * Applys a mass dependant force to all given bodies.
     * @method _bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */ /**
     * Applys `Body.update` to all given `bodies`.
     * @method _bodiesUpdate
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */o.create=function(e,t){t=g.isElement(e)?t:e,e=g.isElement(e)?e:null,t=t||{},(e||t.render)&&g.warn("Engine.create: engine.render is deprecated (see docs)");var i=g.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},timing:{timestamp:0,timeScale:1},broadphase:{controller:c}},t);// @deprecated
if(e||i.render){var o={element:e,controller:a};i.render=g.extend(o,i.render)}// @deprecated
return i.render&&i.render.controller&&(i.render=i.render.controller.create(i.render)),i.render&&(i.render.engine=i),i.world=t.world||n.create(i.world),i.pairs=l.create(),i.broadphase=i.broadphase.controller.create(i.broadphase),i.metrics=i.metrics||{extended:!1},i},o.update=function(e,t,n){t=t||1e3/60,n=n||1;var a=e.world,d=e.timing,c=e.broadphase,g=[],u;// increment timestamp
d.timestamp+=t*d.timeScale;// create an event object
var x={timestamp:d.timestamp};p.trigger(e,"beforeUpdate",x);// get lists of all bodies and constraints, no matter what composites they are in
var h=m.allBodies(a),v=m.allConstraints(a);// if sleeping enabled, call the sleeping controller
for(e.enableSleeping&&s.update(h,d.timeScale),o._bodiesApplyGravity(h,a.gravity),o._bodiesUpdate(h,t,d.timeScale,n,a.bounds),y.preSolveAll(h),u=0;u<e.constraintIterations;u++)y.solveAll(v,d.timeScale);y.postSolveAll(h),c.controller?(a.isModified&&c.controller.clear(c),c.controller.update(c,h,e,a.isModified),g=c.pairsList):g=h,a.isModified&&m.setModified(a,!1,!1,!0);// narrowphase pass: find actual collisions, then create or update collision pairs
var b=c.detector(g,e),f=e.pairs,S=d.timestamp;// update collision pairs
for(l.update(f,b,S),l.removeOld(f,S),e.enableSleeping&&s.afterCollisions(f.list,d.timeScale),0<f.collisionStart.length&&p.trigger(e,"collisionStart",{pairs:f.collisionStart}),r.preSolvePosition(f.list),u=0;u<e.positionIterations;u++)r.solvePosition(f.list,d.timeScale);for(r.postSolvePosition(h),y.preSolveAll(h),u=0;u<e.constraintIterations;u++)y.solveAll(v,d.timeScale);for(y.postSolveAll(h),r.preSolveVelocity(f.list),u=0;u<e.velocityIterations;u++)r.solveVelocity(f.list,d.timeScale);// trigger collision events
return 0<f.collisionActive.length&&p.trigger(e,"collisionActive",{pairs:f.collisionActive}),0<f.collisionEnd.length&&p.trigger(e,"collisionEnd",{pairs:f.collisionEnd}),o._bodiesClearForces(h),p.trigger(e,"afterUpdate",x),e},o.merge=function(e,t){if(g.extend(e,t),t.world){e.world=t.world,o.clear(e);for(var n=m.allBodies(e.world),r=0,a;r<n.length;r++)a=n[r],s.set(a,!1),a.id=g.nextId()}},o.clear=function(e){var t=e.world;l.clear(e.pairs);var i=e.broadphase;if(i.controller){var o=m.allBodies(t);i.controller.clear(i),i.controller.update(i,o,e,!0)}},o._bodiesClearForces=function(e){for(var t=0,o;t<e.length;t++)// reset force buffers
o=e[t],o.force.x=0,o.force.y=0,o.torque=0},o._bodiesApplyGravity=function(e,t){var o="undefined"==typeof t.scale?.001:t.scale;if((0!==t.x||0!==t.y)&&0!==o)for(var n=0,s;n<e.length;n++)s=e[n],s.isStatic||s.isSleeping||(s.force.y+=s.mass*t.y*o,s.force.x+=s.mass*t.x*o)},o._bodiesUpdate=function(e,t,o,n){for(var s=0,r;s<e.length;s++)r=e[s],r.isStatic||r.isSleeping||u.update(r,t,o,n)}})()},{"../body/Body":1,"../body/Composite":2,"../body/World":3,"../collision/Grid":6,"../collision/Pairs":8,"../collision/Resolver":10,"../constraint/Constraint":12,"../render/Render":31,"./Common":14,"./Events":16,"./Metrics":18,"./Sleeping":22}],16:[function(e,t){/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/var i={};t.exports=i;var o=e("./Common");(function(){/**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */ /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */ /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */i.on=function(e,t,o){for(var n=t.split(" "),s=0,r;s<n.length;s++)r=n[s],e.events=e.events||{},e.events[r]=e.events[r]||[],e.events[r].push(o);return o},i.off=function(e,t,n){if(!t)return void(e.events={});// handle Events.off(object, callback)
"function"==typeof t&&(n=t,t=o.keys(e.events).join(" "));for(var s=t.split(" "),r=0;r<s.length;r++){var a=e.events[s[r]],l=[];if(n&&a)for(var d=0;d<a.length;d++)a[d]!==n&&l.push(a[d]);e.events[s[r]]=l}},i.trigger=function(e,t,n){var s,r,a,l;if(e.events){n||(n={}),s=t.split(" ");for(var d=0;d<s.length;d++)if(r=s[d],a=e.events[r],a){l=o.clone(n,!1),l.name=r,l.source=e;for(var c=0;c<a.length;c++)a[c].apply(e,[l])}}}})()},{"./Common":14}],17:[function(e,t){/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/var i={};t.exports=i;var o=e("./Plugin"),n=e("./Common");(function(){/**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */ /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */ /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */ /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */ /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */ /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */ /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */i.name="matter-js",i.version="0.14.2",i.uses=[],i.used=[],i.use=function(){o.use(i,Array.prototype.slice.call(arguments))},i.before=function(e,t){return e=e.replace(/^Matter./,""),n.chainPathBefore(i,e,t)},i.after=function(e,t){return e=e.replace(/^Matter./,""),n.chainPathAfter(i,e,t)}})()},{"./Common":14,"./Plugin":20}],18:[function(){},{"../body/Composite":2,"./Common":14}],19:[function(e,t){/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/var i={};t.exports=i;var o=e("../core/Common");(function(){/**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */ /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */ /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */ /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */ /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */ /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */i.create=function(e){var t={};return e||o.log("Mouse.create: element was undefined, defaulting to document.body","warn"),t.element=e||document.body,t.absolute={x:0,y:0},t.position={x:0,y:0},t.mousedownPosition={x:0,y:0},t.mouseupPosition={x:0,y:0},t.offset={x:0,y:0},t.scale={x:1,y:1},t.wheelDelta=0,t.button=-1,t.pixelRatio=t.element.getAttribute("data-pixel-ratio")||1,t.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null},t.mousemove=function(e){var o=i._getRelativeMousePosition(e,t.element,t.pixelRatio),n=e.changedTouches;n&&(t.button=0,e.preventDefault()),t.absolute.x=o.x,t.absolute.y=o.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.sourceEvents.mousemove=e},t.mousedown=function(e){var o=i._getRelativeMousePosition(e,t.element,t.pixelRatio),n=e.changedTouches;n?(t.button=0,e.preventDefault()):t.button=e.button,t.absolute.x=o.x,t.absolute.y=o.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mousedownPosition.x=t.position.x,t.mousedownPosition.y=t.position.y,t.sourceEvents.mousedown=e},t.mouseup=function(e){var o=i._getRelativeMousePosition(e,t.element,t.pixelRatio),n=e.changedTouches;n&&e.preventDefault(),t.button=-1,t.absolute.x=o.x,t.absolute.y=o.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mouseupPosition.x=t.position.x,t.mouseupPosition.y=t.position.y,t.sourceEvents.mouseup=e},t.mousewheel=function(e){t.wheelDelta=s(-1,r(1,e.wheelDelta||-e.detail)),e.preventDefault()},i.setElement(t,t.element),t},i.setElement=function(e,t){e.element=t,t.addEventListener("mousemove",e.mousemove),t.addEventListener("mousedown",e.mousedown),t.addEventListener("mouseup",e.mouseup),t.addEventListener("mousewheel",e.mousewheel),t.addEventListener("DOMMouseScroll",e.mousewheel),t.addEventListener("touchmove",e.mousemove),t.addEventListener("touchstart",e.mousedown),t.addEventListener("touchend",e.mouseup)},i.clearSourceEvents=function(e){e.sourceEvents.mousemove=null,e.sourceEvents.mousedown=null,e.sourceEvents.mouseup=null,e.sourceEvents.mousewheel=null,e.wheelDelta=0},i.setOffset=function(e,t){e.offset.x=t.x,e.offset.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},i.setScale=function(e,t){e.scale.x=t.x,e.scale.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},i._getRelativeMousePosition=function(e,t,i){var o=t.getBoundingClientRect(),n=document.documentElement||document.body.parentNode||document.body,s=void 0===window.pageXOffset?n.scrollLeft:window.pageXOffset,r=void 0===window.pageYOffset?n.scrollTop:window.pageYOffset,a=e.changedTouches,l,d;return a?(l=a[0].pageX-o.left-s,d=a[0].pageY-o.top-r):(l=e.pageX-o.left-s,d=e.pageY-o.top-r),{x:l/(t.clientWidth/(t.width||t.clientWidth)*i),y:d/(t.clientHeight/(t.height||t.clientHeight)*i)}}})()},{"../core/Common":14}],20:[function(e,t){/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/var o={};t.exports=o;var n=e("./Common");(function(){/**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */ /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */ /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */ /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */ /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */ /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */ /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick ✅ indicates a dependency was resolved and installed.
     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross ❌ indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */ /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */ /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */ /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */ /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */o._registry={},o.register=function(e){if(o.isPlugin(e)||n.warn("Plugin.register:",o.toString(e),"does not implement all required fields."),e.name in o._registry){var t=o._registry[e.name],i=o.versionParse(e.version).number,s=o.versionParse(t.version).number;i>s?(n.warn("Plugin.register:",o.toString(t),"was upgraded to",o.toString(e)),o._registry[e.name]=e):i<s?n.warn("Plugin.register:",o.toString(t),"can not be downgraded to",o.toString(e)):e!==t&&n.warn("Plugin.register:",o.toString(e),"is already registered to different plugin object")}else o._registry[e.name]=e;return e},o.resolve=function(e){return o._registry[o.dependencyParse(e).name]},o.toString=function(e){return"string"==typeof e?e:(e.name||"anonymous")+"@"+(e.version||e.range||"0.0.0")},o.isPlugin=function(e){return e&&e.name&&e.version&&e.install},o.isUsed=function(e,t){return-1<e.used.indexOf(t)},o.isFor=function(e,t){var i=e.for&&o.dependencyParse(e.for);return!e.for||t.name===i.name&&o.versionSatisfies(t.version,i.range)},o.use=function(e,t){if(e.uses=(e.uses||[]).concat(t||[]),0===e.uses.length)return void n.warn("Plugin.use:",o.toString(e),"does not specify any dependencies to install.");for(var s=o.dependencies(e),r=n.topologicalSort(s),a=[],l=0;l<r.length;l+=1)if(r[l]!==e.name){var d=o.resolve(r[l]);if(!d){a.push("\u274C "+r[l]);continue}o.isUsed(e,d.name)||(o.isFor(d,e)||(n.warn("Plugin.use:",o.toString(d),"is for",d.for,"but installed on",o.toString(e)+"."),d._warned=!0),d.install?d.install(e):(n.warn("Plugin.use:",o.toString(d),"does not specify an install function."),d._warned=!0),d._warned?(a.push("\uD83D\uDD36 "+o.toString(d)),delete d._warned):a.push("\u2705 "+o.toString(d)),e.used.push(d.name))}0<a.length&&n.info(a.join("  "))},o.dependencies=function(e,t){var s=o.dependencyParse(e),r=s.name;if(t=t||{},!(r in t)){e=o.resolve(e)||e,t[r]=n.map(e.uses||[],function(t){o.isPlugin(t)&&o.register(t);var i=o.dependencyParse(t),r=o.resolve(t);return r&&!o.versionSatisfies(r.version,i.range)?(n.warn("Plugin.dependencies:",o.toString(r),"does not satisfy",o.toString(i),"used by",o.toString(s)+"."),r._warned=!0,e._warned=!0):!r&&(n.warn("Plugin.dependencies:",o.toString(t),"used by",o.toString(s),"could not be resolved."),e._warned=!0),i.name});for(var a=0;a<t[r].length;a+=1)o.dependencies(t[r][a],t);return t}},o.dependencyParse=function(e){if(n.isString(e)){var t=/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;return t.test(e)||n.warn("Plugin.dependencyParse:",e,"is not a valid dependency string."),{name:e.split("@")[0],range:e.split("@")[1]||"*"}}return{name:e.name,range:e.range||e.version}},o.versionParse=function(e){var t=/^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;t.test(e)||n.warn("Plugin.versionParse:",e,"is not a valid version or range.");var i=e.split("-");e=i[0];var o=isNaN(+e[0]),s=o?e.substr(1):e,r=n.map(s.split("."),function(e){return+e});return{isRange:o,version:s,range:e,operator:o?e[0]:"",parts:r,prerelease:i[1],number:1e8*r[0]+1e4*r[1]+r[2]}},o.versionSatisfies=function(e,t){t=t||"*";var i=o.versionParse(t),n=i.parts,s=o.versionParse(e),r=s.parts;if(i.isRange){if("*"===i.operator||"*"===e)return!0;if("~"===i.operator)return r[0]===n[0]&&r[1]===n[1]&&r[2]>=n[2];if("^"===i.operator)return 0<n[0]?r[0]===n[0]&&s.number>=i.number:0<n[1]?r[1]===n[1]&&r[2]>=n[2]:r[2]===n[2]}return e===t||"*"===e}})()},{"./Common":14}],21:[function(e,t){/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/var i={};t.exports=i;var o=e("./Events"),n=e("./Engine"),s=e("./Common");(function(){var e,t;if("undefined"!=typeof window&&(e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame,t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),!e){var a;e=function(e){a=setTimeout(function(){e(s.now())},1e3/60)},t=function(){clearTimeout(a)}}/**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */i.create=function(e){var t=s.extend({fps:60,correction:1,deltaSampleSize:60,counterTimestamp:0,frameCounter:0,deltaHistory:[],timePrev:null,timeScalePrev:1,frameRequestId:null,isFixed:!1,enabled:!0},e);return t.delta=t.delta||1e3/t.fps,t.deltaMin=t.deltaMin||1e3/t.fps,t.deltaMax=t.deltaMax||1e3/(.5*t.fps),t.fps=1e3/t.delta,t},i.run=function(t,o){return"undefined"!=typeof t.positionIterations&&(o=t,t=i.create()),function n(s){t.frameRequestId=e(n),s&&t.enabled&&i.tick(t,o,s)}(),t},i.tick=function(e,t,i){var s=t.timing,a=1,l={timestamp:s.timestamp},d;// create an event object
o.trigger(e,"beforeTick",l),o.trigger(t,"beforeTick",l),e.isFixed?d=e.delta:(d=i-e.timePrev||e.delta,e.timePrev=i,e.deltaHistory.push(d),e.deltaHistory=e.deltaHistory.slice(-e.deltaSampleSize),d=r.apply(null,e.deltaHistory),d=d<e.deltaMin?e.deltaMin:d,d=d>e.deltaMax?e.deltaMax:d,a=d/e.delta,e.delta=d),0!==e.timeScalePrev&&(a*=s.timeScale/e.timeScalePrev),0===s.timeScale&&(a=0),e.timeScalePrev=s.timeScale,e.correction=a,e.frameCounter+=1,1e3<=i-e.counterTimestamp&&(e.fps=e.frameCounter*((i-e.counterTimestamp)/1e3),e.counterTimestamp=i,e.frameCounter=0),o.trigger(e,"tick",l),o.trigger(t,"tick",l),t.world.isModified&&t.render&&t.render.controller&&t.render.controller.clear&&t.render.controller.clear(t.render),o.trigger(e,"beforeUpdate",l),n.update(t,d,a),o.trigger(e,"afterUpdate",l),t.render&&t.render.controller&&(o.trigger(e,"beforeRender",l),o.trigger(t,"beforeRender",l),t.render.controller.world(t.render),o.trigger(e,"afterRender",l),o.trigger(t,"afterRender",l)),o.trigger(e,"afterTick",l),o.trigger(t,"afterTick",l)},i.stop=function(e){t(e.frameRequestId)},i.start=function(e,t){i.run(e,t)}})()},{"./Common":14,"./Engine":15,"./Events":16}],22:[function(e,t){/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/var o={};t.exports=o;var n=e("./Events");(function(){/**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */ /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */ /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */o._motionWakeThreshold=.18,o._motionSleepThreshold=.08,o._minBias=.9,o.update=function(e,t){// update bodies sleeping status
for(var n=0;n<e.length;n++){var a=e[n],l=a.speed*a.speed+a.angularSpeed*a.angularSpeed;// wake up bodies if they have a force applied
if(0!==a.force.x||0!==a.force.y){o.set(a,!1);continue}var d=r(a.motion,l),c=s(a.motion,l);// biased average motion estimation between frames
a.motion=o._minBias*d+(1-o._minBias)*c,0<a.sleepThreshold&&a.motion<o._motionSleepThreshold*(t*t*t)?(a.sleepCounter+=1,a.sleepCounter>=a.sleepThreshold&&o.set(a,!0)):0<a.sleepCounter&&(a.sleepCounter-=1)}},o.afterCollisions=function(e,t){// wake up bodies involved in collisions
for(var n=0,s;n<e.length;n++)// don't wake inactive pairs
if(s=e[n],s.isActive){var r=s.collision,a=r.bodyA.parent,l=r.bodyB.parent;// don't wake if at least one body is static
if(!(a.isSleeping&&l.isSleeping||a.isStatic||l.isStatic)&&(a.isSleeping||l.isSleeping)){var d=a.isSleeping&&!a.isStatic?a:l,c=d===a?l:a;!d.isStatic&&c.motion>o._motionWakeThreshold*(t*t*t)&&o.set(d,!1)}}},o.set=function(e,t){var i=e.isSleeping;t?(e.isSleeping=!0,e.sleepCounter=e.sleepThreshold,e.positionImpulse.x=0,e.positionImpulse.y=0,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.anglePrev=e.angle,e.speed=0,e.angularSpeed=0,e.motion=0,!i&&n.trigger(e,"sleepStart")):(e.isSleeping=!1,e.sleepCounter=0,i&&n.trigger(e,"sleepEnd"))}})()},{"./Events":16}],23:[function(e,i){/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/ // TODO: true circle bodies
var n={};i.exports=n;var a=e("../geometry/Vertices"),c=e("../core/Common"),p=e("../body/Body"),m=e("../geometry/Bounds"),y=e("../geometry/Vector"),g;(function(){/**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */ /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */ /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */ /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */ /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */n.rectangle=function(e,t,i,o,n){n=n||{};var s={label:"Rectangle Body",position:{x:e,y:t},vertices:a.fromPath("L 0 0 L "+i+" 0 L "+i+" "+o+" L 0 "+o)};if(n.chamfer){var r=n.chamfer;s.vertices=a.chamfer(s.vertices,r.radius,r.quality,r.qualityMin,r.qualityMax),delete n.chamfer}return p.create(c.extend({},s,n))},n.trapezoid=function(e,t,i,o,n,s){s=s||{},n*=.5;var r=(1-2*n)*i,l=i*n,d=l+r,m=d+l,y;y=.5>n?"L 0 0 L "+l+" "+-o+" L "+d+" "+-o+" L "+m+" 0":"L 0 0 L "+d+" "+-o+" L "+m+" 0";var g={label:"Trapezoid Body",position:{x:e,y:t},vertices:a.fromPath(y)};if(s.chamfer){var u=s.chamfer;g.vertices=a.chamfer(g.vertices,u.radius,u.quality,u.qualityMin,u.qualityMax),delete s.chamfer}return p.create(c.extend({},g,s))},n.circle=function(e,t,i,a,l){a=a||{};l=l||25;var d=o(s(10,r(l,i)));// optimisation: always use even number of sides (half the number of unique axes)
return 1==d%2&&(d+=1),n.polygon(e,t,d,i,c.extend({},{label:"Circle Body",circleRadius:i},a))},n.polygon=function(e,o,s,r,m){if(m=m||{},3>s)return n.circle(e,o,r,m);for(var y=2*t/s,g="",u=0;u<s;u+=1){var x=.5*y+u*y,h=d(x)*r,v=l(x)*r;g+="L "+h.toFixed(3)+" "+v.toFixed(3)+" "}var b={label:"Polygon Body",position:{x:e,y:o},vertices:a.fromPath(g)};if(m.chamfer){var f=m.chamfer;b.vertices=a.chamfer(b.vertices,f.radius,f.quality,f.qualityMin,f.qualityMax),delete m.chamfer}return p.create(c.extend({},b,m))},n.fromVertices=function(e,t,o,n,s,r,l){g||(g=c._requireGlobal("decomp","poly-decomp"));var d,u,x,h,b,f,S,C,w;for(n=n||{},u=[],s="undefined"!=typeof s&&s,r="undefined"==typeof r?.01:r,l="undefined"==typeof l?10:l,g||c.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."),c.isArray(o[0])||(o=[o]),C=0;C<o.length;C+=1)if(h=o[C],x=a.isConvex(h),x||!g)h=x?a.clockwiseSort(h):a.hull(h),u.push({position:{x:e,y:t},vertices:h});else{// initialise a decomposition
var A=h.map(function(e){return[e.x,e.y]});// vertices are concave and simple, we can decompose into parts
g.makeCCW(A),!1!==r&&g.removeCollinearPoints(A,r);// use the quick decomposition algorithm (Bayazit)
var P=g.quickDecomp(A);// for each decomposed chunk
for(b=0;b<P.length;b++){var B=P[b],I=B.map(function(e){return{x:e[0],y:e[1]}});// convert vertices into the correct structure
0<l&&a.area(I)<l||u.push({position:a.centre(I),vertices:I})}}// create body parts
for(b=0;b<u.length;b++)u[b]=p.create(c.extend(u[b],n));// flag internal edges (coincident part edges)
if(s){for(b=0;b<u.length;b++){var _=u[b];for(f=b+1;f<u.length;f++){var T=u[f];if(m.overlaps(_.bounds,T.bounds)){var R=_.vertices,M=T.vertices;// iterate vertices of both parts
for(S=0;S<_.vertices.length;S++)for(w=0;w<T.vertices.length;w++){// find distances between the vertices
var V=y.magnitudeSquared(y.sub(R[(S+1)%R.length],M[w])),E=y.magnitudeSquared(y.sub(R[S],M[(w+1)%M.length]));// if both vertices are very close, consider the edge concident (internal)
V<5&&E<5&&(R[S].isInternal=!0,M[w].isInternal=!0)}}}}}return 1<u.length?(d=p.create(c.extend({parts:u.slice(0)},n)),p.setPosition(d,{x:e,y:t}),d):u[0]}})()},{"../body/Body":1,"../core/Common":14,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],24:[function(e,t){/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/var i={};t.exports=i;var n=e("../body/Composite"),s=e("../constraint/Constraint"),a=e("../core/Common"),l=e("../body/Body"),d=e("./Bodies");(function(){/**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */ /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */ /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */ /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */ /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */ /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */ /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */i.stack=function(e,t,o,s,r,a,d){for(var c=n.create({label:"Stack"}),p=e,m=t,g=0,u=0,h,v;u<s;u++){v=0;for(var b=0,f;b<o;b++)if(f=d(p,m,b,u,h,g),f){var S=f.bounds.max.y-f.bounds.min.y,C=f.bounds.max.x-f.bounds.min.x;S>v&&(v=S),l.translate(f,{x:.5*C,y:.5*S}),p=f.bounds.max.x+r,n.addBody(c,f),h=f,g+=1}else p+=r;m+=v+a,p=e}return c},i.chain=function(e,t,o,r,l,d){for(var c=e.bodies,p=1;p<c.length;p++){var m=c[p-1],y=c[p],g=m.bounds.max.y-m.bounds.min.y,u=m.bounds.max.x-m.bounds.min.x,x=y.bounds.max.y-y.bounds.min.y,h=y.bounds.max.x-y.bounds.min.x,v=a.extend({bodyA:m,pointA:{x:u*t,y:g*o},bodyB:y,pointB:{x:h*r,y:x*l}},d);n.addConstraint(e,s.create(v))}return e.label+=" Chain",e},i.mesh=function(e,t,i,o,r){var l=e.bodies,d,c,p,m,y;for(d=0;d<i;d++){for(c=1;c<t;c++)p=l[c-1+d*t],m=l[c+d*t],n.addConstraint(e,s.create(a.extend({bodyA:p,bodyB:m},r)));if(0<d)for(c=0;c<t;c++)p=l[c+(d-1)*t],m=l[c+d*t],n.addConstraint(e,s.create(a.extend({bodyA:p,bodyB:m},r))),o&&0<c&&(y=l[c-1+(d-1)*t],n.addConstraint(e,s.create(a.extend({bodyA:y,bodyB:m},r)))),o&&c<t-1&&(y=l[c+1+(d-1)*t],n.addConstraint(e,s.create(a.extend({bodyA:y,bodyB:m},r))))}return e.label+=" Mesh",e},i.pyramid=function(e,t,n,s,a,d,c){return i.stack(e,t,n,s,a,d,function(t,d,p,m,y,g){var i=r(s,o(n/2)),u=y?y.bounds.max.x-y.bounds.min.x:0;if(!(m>i)){m=i-m;var x=m,h=n-1-m;if(!(p<x||p>h)){1===g&&l.translate(y,{x:(p+(1==n%2?1:-1))*u,y:0});var v=y?p*u:0;return c(e+v+p*a,d,p,m,y,g)}// retroactively fix the first body's position, since width was unknown
}// reverse row order
})},i.newtonsCradle=function(e,t,o,r,a){for(var l=n.create({label:"Newtons Cradle"}),c=0;c<o;c++){var p=1.9,m=d.circle(e+c*(r*p),t+a,r,{inertia:1/0,restitution:1,friction:0,frictionAir:1e-4,slop:1}),y=s.create({pointA:{x:e+c*(r*p),y:t},bodyB:m});n.addBody(l,m),n.addConstraint(l,y)}return l},i.car=function(e,t,i,o,r){var a=l.nextGroup(!0),c=.5*-i+20,p=.5*i-20,m=n.create({label:"Car"}),y=d.rectangle(e,t,i,o,{collisionFilter:{group:a},chamfer:{radius:.5*o},density:2e-4}),g=d.circle(e+c,t+0,r,{collisionFilter:{group:a},friction:.8}),u=d.circle(e+p,t+0,r,{collisionFilter:{group:a},friction:.8}),x=s.create({bodyB:y,pointB:{x:c,y:0},bodyA:g,stiffness:1,length:0}),h=s.create({bodyB:y,pointB:{x:p,y:0},bodyA:u,stiffness:1,length:0});return n.addBody(m,y),n.addBody(m,g),n.addBody(m,u),n.addConstraint(m,x),n.addConstraint(m,h),m},i.softBody=function(e,t,o,n,s,r,l,c,p,m){p=a.extend({inertia:1/0},p),m=a.extend({stiffness:.2,render:{type:"line",anchors:!1}},m);var y=i.stack(e,t,o,n,s,r,function(e,t){return d.circle(e,t,c,p)});return i.mesh(y,o,n,l,m),y.label="Soft Body",y}})()},{"../body/Body":1,"../body/Composite":2,"../constraint/Constraint":12,"../core/Common":14,"./Bodies":23}],25:[function(e,t){/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/var i={};t.exports=i;var o=e("../geometry/Vector"),n=e("../core/Common");(function(){/**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */ /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */i.fromVertices=function(e){// find the unique axes, using edge normal gradients
for(var t={},s=0;s<e.length;s++){var r=(s+1)%e.length,a=o.normalise({x:e[r].y-e[s].y,y:e[s].x-e[r].x}),l=0===a.y?1/0:a.x/a.y;// limit precision
l=l.toFixed(3).toString(),t[l]=a}return n.values(t)},i.rotate=function(e,t){if(0!==t)for(var o=d(t),n=l(t),s=0;s<e.length;s++){var r=e[s],a;a=r.x*o-r.y*n,r.y=r.x*n+r.y*o,r.x=a}}})()},{"../core/Common":14,"../geometry/Vector":28}],26:[function(e,t){/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/var i={};t.exports=i,function(){/**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */ /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */ /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */ /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */ /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */ /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */i.create=function(e){var t={min:{x:0,y:0},max:{x:0,y:0}};return e&&i.update(t,e),t},i.update=function(e,t,o){e.min.x=1/0,e.max.x=-Infinity,e.min.y=1/0,e.max.y=-Infinity;for(var n=0,s;n<t.length;n++)s=t[n],s.x>e.max.x&&(e.max.x=s.x),s.x<e.min.x&&(e.min.x=s.x),s.y>e.max.y&&(e.max.y=s.y),s.y<e.min.y&&(e.min.y=s.y);o&&(0<o.x?e.max.x+=o.x:e.min.x+=o.x,0<o.y?e.max.y+=o.y:e.min.y+=o.y)},i.contains=function(e,t){return t.x>=e.min.x&&t.x<=e.max.x&&t.y>=e.min.y&&t.y<=e.max.y},i.overlaps=function(e,t){return e.min.x<=t.max.x&&e.max.x>=t.min.x&&e.max.y>=t.min.y&&e.min.y<=t.max.y},i.translate=function(e,t){e.min.x+=t.x,e.max.x+=t.x,e.min.y+=t.y,e.max.y+=t.y},i.shift=function(e,t){var i=e.max.x-e.min.x,o=e.max.y-e.min.y;e.min.x=t.x,e.max.x=t.x+i,e.min.y=t.y,e.max.y=t.y+o}}()},{}],27:[function(e,t){/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/var o={};t.exports=o;var n=e("../geometry/Bounds"),s=e("../core/Common");(function(){/**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * You must load the `pathseg.js` polyfill on newer browsers.
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */o.pathToVertices=function(e,t){"undefined"==typeof window||"SVGPathSeg"in window||s.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");// https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
var n=[],r=0,a=0,l=0,d,c,p,m,g,u,h,v,b,f,S,C;t=t||15;var w=function(e,t,i){// all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
var o=1==i%2&&1<i;// when the last point doesn't equal the current point add the current point
if(!b||e!=b.x||t!=b.y){b&&o?(S=b.x,C=b.y):(S=0,C=0);var s={x:S+e,y:C+t};// set last point
(o||!b)&&(b=s),n.push(s),a=S+e,l=C+t}},A=function(e){var t=e.pathSegTypeAsLetter.toUpperCase();// skip path ends
"Z"!==t&&(// map segment to x and y
"M"===t||"L"===t||"T"===t||"C"===t||"S"===t||"Q"===t?(a=e.x,l=e.y):"H"===t?a=e.x:"V"===t?l=e.y:void 0,w(a,l,e.pathSegType))};for(o._svgPathToAbsolute(e),p=e.getTotalLength(),u=[],d=0;d<e.pathSegList.numberOfItems;d+=1)u.push(e.pathSegList.getItem(d));// sample through path
for(h=u.concat();r<p;){// new segment
if(f=e.getPathSegAtLength(r),g=u[f],g!=v){for(;h.length&&h[0]!=g;)A(h.shift());v=g}// add points in between when curving
// TODO: adaptive sampling
switch(g.pathSegTypeAsLetter.toUpperCase()){case"C":case"T":case"S":case"Q":case"A":m=e.getPointAtLength(r),w(m.x,m.y,0);}// increment by sample value
r+=t}// add remaining segments not passed by sampling
for(d=0,c=h.length;d<c;++d)A(h[d]);return n},o._svgPathToAbsolute=function(e){// http://phrogz.net/convert-svg-path-to-all-absolute-commands
// Copyright (c) Gavin Kistner
// http://phrogz.net/js/_ReuseLicense.txt
// Modifications: tidy formatting and naming
for(var t=e.pathSegList,o=0,n=0,s=t.numberOfItems,r=0,a,l,d,c,p,m;r<s;++r){var g=t.getItem(r),u=g.pathSegTypeAsLetter;/[MLHVCSQTA]/.test(u)?("x"in g&&(o=g.x),"y"in g&&(n=g.y)):("x1"in g&&(d=o+g.x1),"x2"in g&&(p=o+g.x2),"y1"in g&&(c=n+g.y1),"y2"in g&&(m=n+g.y2),"x"in g&&(o+=g.x),"y"in g&&(n+=g.y),"m"===u?t.replaceItem(e.createSVGPathSegMovetoAbs(o,n),r):"l"===u?t.replaceItem(e.createSVGPathSegLinetoAbs(o,n),r):"h"===u?t.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(o),r):"v"===u?t.replaceItem(e.createSVGPathSegLinetoVerticalAbs(n),r):"c"===u?t.replaceItem(e.createSVGPathSegCurvetoCubicAbs(o,n,d,c,p,m),r):"s"===u?t.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(o,n,p,m),r):"q"===u?t.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(o,n,d,c),r):"t"===u?t.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(o,n),r):"a"===u?t.replaceItem(e.createSVGPathSegArcAbs(o,n,g.r1,g.r2,g.angle,g.largeArcFlag,g.sweepFlag),r):"z"===u||"Z"===u?(o=a,n=l):void 0);("M"==u||"m"==u)&&(a=o,l=n)}}})()},{"../core/Common":14,"../geometry/Bounds":26}],28:[function(t,i){/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/ // TODO: consider params for reusing vector objects
var o={};i.exports=o,function(){/**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */ /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */ /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */ /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */ /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} [output]
     * @return {vector} The vector rotated about (0, 0)
     */ /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */ /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */ /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */ /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */ /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */ /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */ /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */ /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */ /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */ /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */ /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */ /**
     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */ /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */o.create=function(e,t){return{x:e||0,y:t||0}},o.clone=function(e){return{x:e.x,y:e.y}},o.magnitude=function(t){return e(t.x*t.x+t.y*t.y)},o.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y},o.rotate=function(e,t,i){var o=d(t),n=l(t);i||(i={});var s=e.x*o-e.y*n;return i.y=e.x*n+e.y*o,i.x=s,i},o.rotateAbout=function(e,t,i,o){var n=d(t),s=l(t);o||(o={});var r=i.x+((e.x-i.x)*n-(e.y-i.y)*s);return o.y=i.y+((e.x-i.x)*s+(e.y-i.y)*n),o.x=r,o},o.normalise=function(e){var t=o.magnitude(e);return 0===t?{x:0,y:0}:{x:e.x/t,y:e.y/t}},o.dot=function(e,t){return e.x*t.x+e.y*t.y},o.cross=function(e,t){return e.x*t.y-e.y*t.x},o.cross3=function(e,t,i){return(t.x-e.x)*(i.y-e.y)-(t.y-e.y)*(i.x-e.x)},o.add=function(e,t,i){return i||(i={}),i.x=e.x+t.x,i.y=e.y+t.y,i},o.sub=function(e,t,i){return i||(i={}),i.x=e.x-t.x,i.y=e.y-t.y,i},o.mult=function(e,t){return{x:e.x*t,y:e.y*t}},o.div=function(e,t){return{x:e.x/t,y:e.y/t}},o.perp=function(e,t){return t=!0===t?-1:1,{x:t*-e.y,y:t*e.x}},o.neg=function(e){return{x:-e.x,y:-e.y}},o.angle=function(e,t){return Math.atan2(t.y-e.y,t.x-e.x)},o._temp=[o.create(),o.create(),o.create(),o.create(),o.create(),o.create()]}()},{}],29:[function(t,i){/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/var o={};i.exports=o;var s=t("../geometry/Vector"),r=t("../core/Common");(function(){/**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */ /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */ /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */ /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */ /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */ /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */ /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */ /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */ /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */ /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */ /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */ /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */ /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */ /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */o.create=function(e,t){for(var o=[],n=0;n<e.length;n++){var s=e[n],r={x:s.x,y:s.y,index:n,body:t,isInternal:!1};o.push(r)}return o},o.fromPath=function(e,t){var i=/L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,n=[];return e.replace(i,function(e,t,i){n.push({x:parseFloat(t),y:parseFloat(i)})}),o.create(n,t)},o.centre=function(e){for(var t=o.area(e,!0),n={x:0,y:0},r=0,a,l,d;r<e.length;r++)d=(r+1)%e.length,a=s.cross(e[r],e[d]),l=s.mult(s.add(e[r],e[d]),a),n=s.add(n,l);return s.div(n,6*t)},o.mean=function(e){for(var t={x:0,y:0},o=0;o<e.length;o++)t.x+=e[o].x,t.y+=e[o].y;return s.div(t,e.length)},o.area=function(e,t){for(var o=0,n=e.length-1,s=0;s<e.length;s++)o+=(e[n].x-e[s].x)*(e[n].y+e[s].y),n=s;return t?o/2:p(o)/2},o.inertia=function(e,t){// find the polygon's moment of inertia, using second moment of area
// from equations at http://www.physicsforums.com/showthread.php?t=25293
for(var i=0,o=0,r=e,a=0,l,d;a<r.length;a++)d=(a+1)%r.length,l=p(s.cross(r[d],r[a])),i+=l*(s.dot(r[d],r[d])+s.dot(r[d],r[a])+s.dot(r[a],r[a])),o+=l;return t/6*(i/o)},o.translate=function(e,t,o){var n;if(o)for(n=0;n<e.length;n++)e[n].x+=t.x*o,e[n].y+=t.y*o;else for(n=0;n<e.length;n++)e[n].x+=t.x,e[n].y+=t.y;return e},o.rotate=function(e,t,o){if(0!==t){for(var n=d(t),s=l(t),r=0;r<e.length;r++){var a=e[r],c=a.x-o.x,p=a.y-o.y;a.x=o.x+(c*n-p*s),a.y=o.y+(c*s+p*n)}return e}},o.contains=function(e,t){for(var o=0;o<e.length;o++){var n=e[o],s=e[(o+1)%e.length];if(0<(t.x-n.x)*(s.y-n.y)+(t.y-n.y)*(n.x-s.x))return!1}return!0},o.scale=function(e,t,n,r){if(1===t&&1===n)return e;r=r||o.centre(e);for(var a=0,l,d;a<e.length;a++)l=e[a],d=s.sub(l,r),e[a].x=r.x+d.x*t,e[a].y=r.y+d.y*n;return e},o.chamfer=function(t,o,n,l,d){o="number"==typeof o?[o]:o||[8],n="undefined"==typeof n?-1:n,l=l||2,d=d||14;for(var c=[],p=0;p<t.length;p++){var m=t[0<=p-1?p-1:t.length-1],y=t[p],g=t[(p+1)%t.length],u=o[p<o.length?p:o.length-1];if(0===u){c.push(y);continue}var x=s.normalise({x:y.y-m.y,y:m.x-y.x}),h=s.normalise({x:g.y-y.y,y:y.x-g.x}),v=e(2*a(u,2)),b=s.mult(r.clone(x),u),f=s.normalise(s.mult(s.add(x,h),.5)),S=s.sub(y,s.mult(f,v)),C=n;-1===n&&(C=1.75*a(u,.32)),C=r.clamp(C,l,d),1==C%2&&(C+=1);for(var w=Math.acos(s.dot(x,h)),A=w/C,P=0;P<C;P++)c.push(s.add(s.rotate(b,A*P),S))}return c},o.clockwiseSort=function(e){var t=o.mean(e);return e.sort(function(e,i){return s.angle(t,e)-s.angle(t,i)}),e},o.isConvex=function(e){// http://paulbourke.net/geometry/polygonmesh/
// Copyright (c) Paul Bourke (use permitted)
var t=0,o=e.length,n,s,r,a;if(3>o)return null;for(n=0;n<o;n++)if(s=(n+1)%o,r=(n+2)%o,a=(e[s].x-e[n].x)*(e[r].y-e[s].y),a-=(e[s].y-e[n].y)*(e[r].x-e[s].x),0>a?t|=1:0<a&&(t|=2),3===t)return!1;return 0!=t||null},o.hull=function(e){// http://geomalgorithms.com/a10-_hull-1.html
var t=[],o=[],n,r;// sort vertices on x-axis (y-axis for ties)
// build lower hull
for(e=e.slice(0),e.sort(function(e,t){var i=e.x-t.x;return 0==i?e.y-t.y:i}),r=0;r<e.length;r+=1){for(n=e[r];2<=o.length&&0>=s.cross3(o[o.length-2],o[o.length-1],n);)o.pop();o.push(n)}// build upper hull
for(r=e.length-1;0<=r;r-=1){for(n=e[r];2<=t.length&&0>=s.cross3(t[t.length-2],t[t.length-1],n);)t.pop();t.push(n)}// concatenation of the lower and upper hulls gives the convex hull
// omit last points because they are repeated at the beginning of the other list
return t.pop(),o.pop(),t.concat(o)}})()},{"../core/Common":14,"../geometry/Vector":28}],30:[function(e,t){var i=t.exports=e("../core/Matter");// aliases
i.Body=e("../body/Body"),i.Composite=e("../body/Composite"),i.World=e("../body/World"),i.Contact=e("../collision/Contact"),i.Detector=e("../collision/Detector"),i.Grid=e("../collision/Grid"),i.Pairs=e("../collision/Pairs"),i.Pair=e("../collision/Pair"),i.Query=e("../collision/Query"),i.Resolver=e("../collision/Resolver"),i.SAT=e("../collision/SAT"),i.Constraint=e("../constraint/Constraint"),i.MouseConstraint=e("../constraint/MouseConstraint"),i.Common=e("../core/Common"),i.Engine=e("../core/Engine"),i.Events=e("../core/Events"),i.Mouse=e("../core/Mouse"),i.Runner=e("../core/Runner"),i.Sleeping=e("../core/Sleeping"),i.Plugin=e("../core/Plugin"),i.Bodies=e("../factory/Bodies"),i.Composites=e("../factory/Composites"),i.Axes=e("../geometry/Axes"),i.Bounds=e("../geometry/Bounds"),i.Svg=e("../geometry/Svg"),i.Vector=e("../geometry/Vector"),i.Vertices=e("../geometry/Vertices"),i.Render=e("../render/Render"),i.RenderPixi=e("../render/RenderPixi"),i.World.add=i.Composite.add,i.World.remove=i.Composite.remove,i.World.addComposite=i.Composite.addComposite,i.World.addBody=i.Composite.addBody,i.World.addConstraint=i.Composite.addConstraint,i.World.clear=i.Composite.clear,i.Engine.run=i.Runner.run},{"../body/Body":1,"../body/Composite":2,"../body/World":3,"../collision/Contact":4,"../collision/Detector":5,"../collision/Grid":6,"../collision/Pair":7,"../collision/Pairs":8,"../collision/Query":9,"../collision/Resolver":10,"../collision/SAT":11,"../constraint/Constraint":12,"../constraint/MouseConstraint":13,"../core/Common":14,"../core/Engine":15,"../core/Events":16,"../core/Matter":17,"../core/Metrics":18,"../core/Mouse":19,"../core/Plugin":20,"../core/Runner":21,"../core/Sleeping":22,"../factory/Bodies":23,"../factory/Composites":24,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Svg":27,"../geometry/Vector":28,"../geometry/Vertices":29,"../render/Render":31,"../render/RenderPixi":32}],31:[function(e,i){/**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/var s={};i.exports=s;var a=e("../core/Common"),l=e("../body/Composite"),d=e("../geometry/Bounds"),c=e("../core/Events"),m=e("../collision/Grid"),y=e("../geometry/Vector"),g=e("../core/Mouse");(function(){var e,i;"undefined"!=typeof window&&(e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(function(){e(a.now())},1e3/60)},i=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),s.create=function(e){var t={controller:s,engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,options:{width:800,height:600,pixelRatio:1,background:"#18181d",wireframeBackground:"#0f0f13",hasBounds:!!e.bounds,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showBroadphase:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showSeparations:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showShadows:!1,showVertexNumbers:!1,showConvexHulls:!1,showInternalEdges:!1,showMousePosition:!1}},i=a.extend(t,e);return i.canvas&&(i.canvas.width=i.options.width||i.canvas.width,i.canvas.height=i.options.height||i.canvas.height),i.mouse=e.mouse,i.engine=e.engine,i.canvas=i.canvas||u(i.options.width,i.options.height),i.context=i.canvas.getContext("2d"),i.textures={},i.bounds=i.bounds||{min:{x:0,y:0},max:{x:i.canvas.width,y:i.canvas.height}},1!==i.options.pixelRatio&&s.setPixelRatio(i,i.options.pixelRatio),a.isElement(i.element)?i.element.appendChild(i.canvas):!i.canvas.parentNode&&a.log("Render.create: options.element was undefined, render.canvas was created but not appended","warn"),i},s.run=function(t){(function i(){t.frameRequestId=e(i),s.world(t)})()},s.stop=function(e){i(e.frameRequestId)},s.setPixelRatio=function(e,t){var i=e.options,o=e.canvas;"auto"===t&&(t=x(o)),i.pixelRatio=t,o.setAttribute("data-pixel-ratio",t),o.width=i.width*t,o.height=i.height*t,o.style.width=i.width+"px",o.style.height=i.height+"px",e.context.scale(t,t)},s.lookAt=function(e,t,o,n){n=!("undefined"!=typeof n)||n,t=a.isArray(t)?t:[t],o=o||{x:0,y:0};for(var s={min:{x:1/0,y:1/0},max:{x:-Infinity,y:-Infinity}},r=0;r<t.length;r+=1){var l=t[r],d=l.bounds?l.bounds.min:l.min||l.position||l,c=l.bounds?l.bounds.max:l.max||l.position||l;d&&c&&(d.x<s.min.x&&(s.min.x=d.x),c.x>s.max.x&&(s.max.x=c.x),d.y<s.min.y&&(s.min.y=d.y),c.y>s.max.y&&(s.max.y=c.y))}// find ratios
var p=s.max.x-s.min.x+2*o.x,m=s.max.y-s.min.y+2*o.y,y=e.canvas.height,u=e.canvas.width,x=u/y,h=p/m,v=1,b=1;// find scale factor
// enable bounds
// position and size
// padding
h>x?b=h/x:v=x/h,e.options.hasBounds=!0,e.bounds.min.x=s.min.x,e.bounds.max.x=s.min.x+p*v,e.bounds.min.y=s.min.y,e.bounds.max.y=s.min.y+m*b,n&&(e.bounds.min.x+=.5*p-.5*(p*v),e.bounds.max.x+=.5*p-.5*(p*v),e.bounds.min.y+=.5*m-.5*(m*b),e.bounds.max.y+=.5*m-.5*(m*b)),e.bounds.min.x-=o.x,e.bounds.max.x-=o.x,e.bounds.min.y-=o.y,e.bounds.max.y-=o.y,e.mouse&&(g.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.canvas.width,y:(e.bounds.max.y-e.bounds.min.y)/e.canvas.height}),g.setOffset(e.mouse,e.bounds.min))},s.startViewTransform=function(e){var t=e.bounds.max.x-e.bounds.min.x,i=e.bounds.max.y-e.bounds.min.y,o=t/e.options.width,n=i/e.options.height;e.context.scale(1/o,1/n),e.context.translate(-e.bounds.min.x,-e.bounds.min.y)},s.endViewTransform=function(e){e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0)},s.world=function(e){var t=e.engine,o=t.world,n=e.canvas,r=e.context,a=e.options,p=l.allBodies(o),u=l.allConstraints(o),x=a.wireframes?a.wireframeBackground:a.background,h=[],b=[],f={timestamp:t.timing.timestamp},S;// handle bounds
if(c.trigger(e,"beforeRender",f),e.currentBackground!==x&&v(e,x),r.globalCompositeOperation="source-in",r.fillStyle="transparent",r.fillRect(0,0,n.width,n.height),r.globalCompositeOperation="source-over",a.hasBounds){// filter out bodies that are not in view
for(S=0;S<p.length;S++){var C=p[S];d.overlaps(C.bounds,e.bounds)&&h.push(C)}// filter out constraints that are not in view
for(S=0;S<u.length;S++){var w=u[S],A=w.bodyA,P=w.bodyB,B=w.pointA,I=w.pointB;A&&(B=y.add(A.position,w.pointA)),P&&(I=y.add(P.position,w.pointB)),B&&I&&(d.contains(e.bounds,B)||d.contains(e.bounds,I))&&b.push(w)}// transform the view
s.startViewTransform(e),e.mouse&&(g.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.canvas.width,y:(e.bounds.max.y-e.bounds.min.y)/e.canvas.height}),g.setOffset(e.mouse,e.bounds.min))}else b=u,h=p;!a.wireframes||t.enableSleeping&&a.showSleeping?s.bodies(e,h,r):(a.showConvexHulls&&s.bodyConvexHulls(e,h,r),s.bodyWireframes(e,h,r)),a.showBounds&&s.bodyBounds(e,h,r),(a.showAxes||a.showAngleIndicator)&&s.bodyAxes(e,h,r),a.showPositions&&s.bodyPositions(e,h,r),a.showVelocity&&s.bodyVelocity(e,h,r),a.showIds&&s.bodyIds(e,h,r),a.showSeparations&&s.separations(e,t.pairs.list,r),a.showCollisions&&s.collisions(e,t.pairs.list,r),a.showVertexNumbers&&s.vertexNumbers(e,h,r),a.showMousePosition&&s.mousePosition(e,e.mouse,r),s.constraints(b,r),a.showBroadphase&&t.broadphase.controller===m&&s.grid(e,t.broadphase,r),a.showDebug&&s.debug(e,r),a.hasBounds&&s.endViewTransform(e),c.trigger(e,"afterRender",f)},s.debug=function(e,t){var o=t,n=e.engine,s=n.world,r=n.metrics,a=e.options,d=l.allBodies(s);if(500<=n.timing.timestamp-(e.debugTimestamp||0)){var c="";r.timing&&(c+="fps: "+Math.round(r.timing.fps)+"    "),e.debugString=c,e.debugTimestamp=n.timing.timestamp}if(e.debugString){o.font="12px Arial",o.fillStyle=a.wireframes?"rgba(255,255,255,0.5)":"rgba(0,0,0,0.5)";for(var p=e.debugString.split("\n"),m=0;m<p.length;m++)o.fillText(p[m],50,50+18*m)}},s.constraints=function(e,n){for(var s=n,r=0,l;r<e.length;r++)if(l=e[r],l.render.visible&&l.pointA&&l.pointB){var d=l.bodyA,c=l.bodyB,p,m;if(p=d?y.add(d.position,l.pointA):l.pointA,"pin"===l.render.type)s.beginPath(),s.arc(p.x,p.y,3,0,2*t),s.closePath();else{if(m=c?y.add(c.position,l.pointB):l.pointB,s.beginPath(),s.moveTo(p.x,p.y),"spring"===l.render.type)for(var g=y.sub(m,p),u=y.perp(y.normalise(g)),x=o(a.clamp(l.length/5,12,20)),h=1,v;h<x;h+=1)v=0==h%2?1:-1,s.lineTo(p.x+g.x*(h/x)+4*(u.x*v),p.y+g.y*(h/x)+4*(u.y*v));s.lineTo(m.x,m.y)}l.render.lineWidth&&(s.lineWidth=l.render.lineWidth,s.strokeStyle=l.render.strokeStyle,s.stroke()),l.render.anchors&&(s.fillStyle=l.render.strokeStyle,s.beginPath(),s.arc(p.x,p.y,3,0,2*t),s.arc(m.x,m.y,3,0,2*t),s.closePath(),s.fill())}},s.bodyShadows=function(e,o,n){for(var s=n,a=e.engine,l=0,d;l<o.length;l++)if(d=o[l],d.render.visible){if(d.circleRadius)s.beginPath(),s.arc(d.position.x,d.position.y,d.circleRadius,0,2*t),s.closePath();else{s.beginPath(),s.moveTo(d.vertices[0].x,d.vertices[0].y);for(var c=1;c<d.vertices.length;c++)s.lineTo(d.vertices[c].x,d.vertices[c].y);s.closePath()}var m=d.position.x-.5*e.options.width,y=d.position.y-.2*e.options.height,g=p(m)+p(y);s.shadowColor="rgba(0,0,0,0.15)",s.shadowOffsetX=.05*m,s.shadowOffsetY=.05*y,s.shadowBlur=1+12*r(1,g/1e3),s.fill(),s.shadowColor=null,s.shadowOffsetX=null,s.shadowOffsetY=null,s.shadowBlur=null}},s.bodies=function(e,o,n){var s=n,r=e.engine,a=e.options,l=a.showInternalEdges||!a.wireframes,d,c,p,m;for(p=0;p<o.length;p++)if(d=o[p],d.render.visible)// handle compound parts
for(m=1<d.parts.length?1:0;m<d.parts.length;m++)if(c=d.parts[m],c.render.visible){if(a.showSleeping&&d.isSleeping?s.globalAlpha=.5*c.render.opacity:1!==c.render.opacity&&(s.globalAlpha=c.render.opacity),c.render.sprite&&c.render.sprite.texture&&!a.wireframes){// part sprite
var y=c.render.sprite,g=h(e,y.texture);s.translate(c.position.x,c.position.y),s.rotate(c.angle),s.drawImage(g,g.width*-y.xOffset*y.xScale,g.height*-y.yOffset*y.yScale,g.width*y.xScale,g.height*y.yScale),s.rotate(-c.angle),s.translate(-c.position.x,-c.position.y)}else{// part polygon
if(c.circleRadius)s.beginPath(),s.arc(c.position.x,c.position.y,c.circleRadius,0,2*t);else{s.beginPath(),s.moveTo(c.vertices[0].x,c.vertices[0].y);for(var u=1;u<c.vertices.length;u++)!c.vertices[u-1].isInternal||l?s.lineTo(c.vertices[u].x,c.vertices[u].y):s.moveTo(c.vertices[u].x,c.vertices[u].y),c.vertices[u].isInternal&&!l&&s.moveTo(c.vertices[(u+1)%c.vertices.length].x,c.vertices[(u+1)%c.vertices.length].y);s.lineTo(c.vertices[0].x,c.vertices[0].y),s.closePath()}a.wireframes?(s.lineWidth=1,s.strokeStyle="#bbb",s.stroke()):(s.fillStyle=c.render.fillStyle,c.render.lineWidth&&(s.lineWidth=c.render.lineWidth,s.strokeStyle=c.render.strokeStyle,s.stroke()),s.fill())}s.globalAlpha=1}},s.bodyWireframes=function(e,t,o){var n=o,s=e.options.showInternalEdges,r,a,l,d,c;// render all bodies
for(n.beginPath(),l=0;l<t.length;l++)if(r=t[l],r.render.visible)// handle compound parts
for(c=1<r.parts.length?1:0;c<r.parts.length;c++){for(a=r.parts[c],n.moveTo(a.vertices[0].x,a.vertices[0].y),d=1;d<a.vertices.length;d++)!a.vertices[d-1].isInternal||s?n.lineTo(a.vertices[d].x,a.vertices[d].y):n.moveTo(a.vertices[d].x,a.vertices[d].y),a.vertices[d].isInternal&&!s&&n.moveTo(a.vertices[(d+1)%a.vertices.length].x,a.vertices[(d+1)%a.vertices.length].y);n.lineTo(a.vertices[0].x,a.vertices[0].y)}n.lineWidth=1,n.strokeStyle="#bbb",n.stroke()},s.bodyConvexHulls=function(e,t,o){var n=o,s,r,a;// render convex hulls
for(n.beginPath(),r=0;r<t.length;r++)if(s=t[r],s.render.visible&&1!==s.parts.length){for(n.moveTo(s.vertices[0].x,s.vertices[0].y),a=1;a<s.vertices.length;a++)n.lineTo(s.vertices[a].x,s.vertices[a].y);n.lineTo(s.vertices[0].x,s.vertices[0].y)}n.lineWidth=1,n.strokeStyle="rgba(255,255,255,0.2)",n.stroke()},s.vertexNumbers=function(e,t,o){var n=o,s,r,a;for(s=0;s<t.length;s++){var l=t[s].parts;for(a=1<l.length?1:0;a<l.length;a++){var d=l[a];for(r=0;r<d.vertices.length;r++)n.fillStyle="rgba(255,255,255,0.2)",n.fillText(s+"_"+r,d.position.x+.8*(d.vertices[r].x-d.position.x),d.position.y+.8*(d.vertices[r].y-d.position.y))}}},s.mousePosition=function(e,t,i){var o=i;o.fillStyle="rgba(255,255,255,0.8)",o.fillText(t.position.x+"  "+t.position.y,t.position.x+5,t.position.y-5)},s.bodyBounds=function(e,t,o){var n=o,s=e.engine,r=e.options;n.beginPath();for(var a=0,l;a<t.length;a++)if(l=t[a],l.render.visible)for(var d=t[a].parts,c=1<d.length?1:0,p;c<d.length;c++)p=d[c],n.rect(p.bounds.min.x,p.bounds.min.y,p.bounds.max.x-p.bounds.min.x,p.bounds.max.y-p.bounds.min.y);n.strokeStyle=r.wireframes?"rgba(255,255,255,0.08)":"rgba(0,0,0,0.1)",n.lineWidth=1,n.stroke()},s.bodyAxes=function(e,t,o){var n=o,s=e.engine,r=e.options,a,l,d,c;for(n.beginPath(),l=0;l<t.length;l++){var p=t[l],m=p.parts;if(p.render.visible)if(r.showAxes)// render all axes
for(d=1<m.length?1:0;d<m.length;d++)for(a=m[d],c=0;c<a.axes.length;c++){var y=a.axes[c];n.moveTo(a.position.x,a.position.y),n.lineTo(a.position.x+20*y.x,a.position.y+20*y.y)}else for(d=1<m.length?1:0;d<m.length;d++)for(a=m[d],c=0;c<a.axes.length;c++)// render a single axis indicator
n.moveTo(a.position.x,a.position.y),n.lineTo((a.vertices[0].x+a.vertices[a.vertices.length-1].x)/2,(a.vertices[0].y+a.vertices[a.vertices.length-1].y)/2)}r.wireframes?(n.strokeStyle="indianred",n.lineWidth=1):(n.strokeStyle="rgba(255, 255, 255, 0.4)",n.globalCompositeOperation="overlay",n.lineWidth=2),n.stroke(),n.globalCompositeOperation="source-over"},s.bodyPositions=function(e,o,n){var s=n,r=e.engine,a=e.options,l,d,c,p;// render current positions
for(s.beginPath(),c=0;c<o.length;c++)if(l=o[c],l.render.visible)// handle compound parts
for(p=0;p<l.parts.length;p++)d=l.parts[p],s.arc(d.position.x,d.position.y,3,0,2*t,!1),s.closePath();// render previous positions
for(s.fillStyle=a.wireframes?"indianred":"rgba(0,0,0,0.5)",s.fill(),s.beginPath(),c=0;c<o.length;c++)l=o[c],l.render.visible&&(s.arc(l.positionPrev.x,l.positionPrev.y,2,0,2*t,!1),s.closePath());s.fillStyle="rgba(255,165,0,0.8)",s.fill()},s.bodyVelocity=function(e,t,o){var n=o;n.beginPath();for(var s=0,r;s<t.length;s++)r=t[s],r.render.visible&&(n.moveTo(r.position.x,r.position.y),n.lineTo(r.position.x+2*(r.position.x-r.positionPrev.x),r.position.y+2*(r.position.y-r.positionPrev.y)));n.lineWidth=3,n.strokeStyle="cornflowerblue",n.stroke()},s.bodyIds=function(e,t,o){var n=o,s,r;for(s=0;s<t.length;s++)if(t[s].render.visible){var a=t[s].parts;for(r=1<a.length?1:0;r<a.length;r++){var l=a[r];n.font="12px Arial",n.fillStyle="rgba(255,255,255,0.5)",n.fillText(l.id,l.position.x+10,l.position.y-10)}}},s.collisions=function(e,t,o){var n=o,s=e.options,r,a,l,d;// render collision positions
for(n.beginPath(),l=0;l<t.length;l++)if(r=t[l],r.isActive)for(a=r.collision,d=0;d<r.activeContacts.length;d++){var c=r.activeContacts[d],p=c.vertex;n.rect(p.x-1.5,p.y-1.5,3.5,3.5)}// render collision normals
for(n.fillStyle=s.wireframes?"rgba(255,255,255,0.7)":"orange",n.fill(),n.beginPath(),l=0;l<t.length;l++)if(r=t[l],r.isActive&&(a=r.collision,0<r.activeContacts.length)){var m=r.activeContacts[0].vertex.x,y=r.activeContacts[0].vertex.y;2===r.activeContacts.length&&(m=(r.activeContacts[0].vertex.x+r.activeContacts[1].vertex.x)/2,y=(r.activeContacts[0].vertex.y+r.activeContacts[1].vertex.y)/2),a.bodyB===a.supports[0].body||!0===a.bodyA.isStatic?n.moveTo(m-8*a.normal.x,y-8*a.normal.y):n.moveTo(m+8*a.normal.x,y+8*a.normal.y),n.lineTo(m,y)}n.strokeStyle=s.wireframes?"rgba(255,165,0,0.7)":"orange",n.lineWidth=1,n.stroke()},s.separations=function(e,t,o){var n=o,s=e.options,r,a,l,d,c;// render separations
for(n.beginPath(),c=0;c<t.length;c++)if(r=t[c],r.isActive){a=r.collision,l=a.bodyA,d=a.bodyB;var p=1;d.isStatic||l.isStatic||(p=.5),d.isStatic&&(p=0),n.moveTo(d.position.x,d.position.y),n.lineTo(d.position.x-a.penetration.x*p,d.position.y-a.penetration.y*p),p=1,d.isStatic||l.isStatic||(p=.5),l.isStatic&&(p=0),n.moveTo(l.position.x,l.position.y),n.lineTo(l.position.x+a.penetration.x*p,l.position.y+a.penetration.y*p)}n.strokeStyle=s.wireframes?"rgba(255,165,0,0.5)":"orange",n.stroke()},s.grid=function(e,t,o){var n=o,s=e.options;n.strokeStyle=s.wireframes?"rgba(255,180,0,0.1)":"rgba(255,180,0,0.5)",n.beginPath();for(var r=a.keys(t.buckets),l=0,d;l<r.length;l++)if(d=r[l],!(2>t.buckets[d].length)){var c=d.split(/C|R/);n.rect(.5+parseInt(c[1],10)*t.bucketWidth,.5+parseInt(c[2],10)*t.bucketHeight,t.bucketWidth,t.bucketHeight)}n.lineWidth=1,n.stroke()},s.inspector=function(e,o){var s=e.engine,r=e.selected,a=e.render,l=a.options,d;if(l.hasBounds){var c=a.bounds.max.x-a.bounds.min.x,p=a.bounds.max.y-a.bounds.min.y,m=c/a.options.width,y=p/a.options.height;o.scale(1/m,1/y),o.translate(-a.bounds.min.x,-a.bounds.min.y)}for(var g=0,u;g<r.length;g++){switch(u=r[g].data,o.translate(.5,.5),o.lineWidth=1,o.strokeStyle="rgba(255,165,0,0.9)",o.setLineDash([1,2]),u.type){case"body":d=u.bounds,o.beginPath(),o.rect(n(d.min.x-3),n(d.min.y-3),n(d.max.x-d.min.x+6),n(d.max.y-d.min.y+6)),o.closePath(),o.stroke();break;case"constraint":// render constraint selections
var x=u.pointA;u.bodyA&&(x=u.pointB),o.beginPath(),o.arc(x.x,x.y,10,0,2*t),o.closePath(),o.stroke();}o.setLineDash([]),o.translate(-.5,-.5)}// render selection region
null!==e.selectStart&&(o.translate(.5,.5),o.lineWidth=1,o.strokeStyle="rgba(255,165,0,0.6)",o.fillStyle="rgba(255,165,0,0.1)",d=e.selectBounds,o.beginPath(),o.rect(n(d.min.x),n(d.min.y),n(d.max.x-d.min.x),n(d.max.y-d.min.y)),o.closePath(),o.stroke(),o.fill(),o.translate(-.5,-.5)),l.hasBounds&&o.setTransform(1,0,0,1,0,0)};/**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */var u=function(e,t){var i=document.createElement("canvas");return i.width=e,i.height=t,i.oncontextmenu=function(){return!1},i.onselectstart=function(){return!1},i},x=function(e){var t=e.getContext("2d"),i=window.devicePixelRatio||1,o=t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1;return i/o},h=function(e,t){var i=e.textures[t];return i?i:(i=e.textures[t]=new Image,i.src=t,i)},v=function(e,t){var i=t;/(jpg|gif|png)$/.test(t)&&(i="url("+t+")"),e.canvas.style.background=i,e.canvas.style.backgroundSize="contain",e.currentBackground=t};/**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */ /*
    *
    *  Events Documentation
    *
    */ /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */ /*
    *
    *  Properties Documentation
    *
    */ /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */ /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */ /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */ /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */ /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */ /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */ /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */ /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */ /**
     * A `Bounds` object that specifies the drawing view region.
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */ /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */ /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */})()},{"../body/Composite":2,"../collision/Grid":6,"../core/Common":14,"../core/Events":16,"../core/Mouse":19,"../geometry/Bounds":26,"../geometry/Vector":28}],32:[function(e,t){/**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/var o={};t.exports=o;var n=e("../geometry/Bounds"),s=e("../body/Composite"),r=e("../core/Common"),a=e("../core/Events"),l=e("../geometry/Vector");(function(){var e,t;"undefined"!=typeof window&&(e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(function(){e(r.now())},1e3/60)},t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),o.create=function(e){r.warn("RenderPixi.create: Matter.RenderPixi is deprecated (see docs)");var t=r.extend({controller:o,engine:null,element:null,frameRequestId:null,canvas:null,renderer:null,container:null,spriteContainer:null,pixiOptions:null,options:{width:800,height:600,background:"#fafafa",wireframeBackground:"#222",hasBounds:!1,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showBroadphase:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showShadows:!1}},e),i=!t.options.wireframes&&"transparent"===t.options.background;return t.pixiOptions=t.pixiOptions||{view:t.canvas,transparent:i,antialias:!0,backgroundColor:e.background},t.mouse=e.mouse,t.engine=e.engine,t.renderer=t.renderer||new PIXI.WebGLRenderer(t.options.width,t.options.height,t.pixiOptions),t.container=t.container||new PIXI.Container,t.spriteContainer=t.spriteContainer||new PIXI.Container,t.canvas=t.canvas||t.renderer.view,t.bounds=t.bounds||{min:{x:0,y:0},max:{x:t.options.width,y:t.options.height}},a.on(t.engine,"beforeUpdate",function(){o.clear(t)}),t.textures={},t.sprites={},t.primitives={},t.container.addChild(t.spriteContainer),r.isElement(t.element)?t.element.appendChild(t.canvas):r.warn("No \"render.element\" passed, \"render.canvas\" was not inserted into document."),t.canvas.oncontextmenu=function(){return!1},t.canvas.onselectstart=function(){return!1},t},o.run=function(t){(function i(){t.frameRequestId=e(i),o.world(t)})()},o.stop=function(e){t(e.frameRequestId)},o.clear=function(e){// clear stage container
for(var t=e.container,i=e.spriteContainer;t.children[0];)t.removeChild(t.children[0]);// clear sprite batch
for(;i.children[0];)i.removeChild(i.children[0]);var o=e.sprites["bg-0"];// clear caches
// set background sprite
// add sprite batch back into container
// reset background state
// reset bounds transforms
e.textures={},e.sprites={},e.primitives={},e.sprites["bg-0"]=o,o&&t.addChildAt(o,0),e.container.addChild(e.spriteContainer),e.currentBackground=null,t.scale.set(1,1),t.position.set(0,0)},o.setBackground=function(e,t){if(e.currentBackground!==t){var i=t.indexOf&&-1!==t.indexOf("#"),o=e.sprites["bg-0"];if(i){// if solid background color
var n=r.colorToNumber(t);e.renderer.backgroundColor=n,o&&e.container.removeChild(o)}else// initialise background sprite if needed
if(!o){var s=c(e,t);o=e.sprites["bg-0"]=new PIXI.Sprite(s),o.position.x=0,o.position.y=0,e.container.addChildAt(o,0)}e.currentBackground=t}},o.world=function(e){var t=e.engine,r=t.world,a=e.renderer,d=e.container,c=e.options,p=s.allBodies(r),m=s.allConstraints(r),y=[],g;c.wireframes?o.setBackground(e,c.wireframeBackground):o.setBackground(e,c.background);// handle bounds
var u=e.bounds.max.x-e.bounds.min.x,x=e.bounds.max.y-e.bounds.min.y,h=u/e.options.width,v=x/e.options.height;if(c.hasBounds){// Hide bodies that are not in view
for(g=0;g<p.length;g++){var b=p[g];b.render.sprite.visible=n.overlaps(b.bounds,e.bounds)}// filter out constraints that are not in view
for(g=0;g<m.length;g++){var f=m[g],S=f.bodyA,C=f.bodyB,w=f.pointA,A=f.pointB;S&&(w=l.add(S.position,f.pointA)),C&&(A=l.add(C.position,f.pointB)),w&&A&&(n.contains(e.bounds,w)||n.contains(e.bounds,A))&&y.push(f)}// transform the view
d.scale.set(1/h,1/v),d.position.set(-e.bounds.min.x*(1/h),-e.bounds.min.y*(1/v))}else y=m;for(g=0;g<p.length;g++)o.body(e,p[g]);for(g=0;g<y.length;g++)o.constraint(e,y[g]);a.render(d)},o.constraint=function(e,t){var i=e.engine,o=t.bodyA,n=t.bodyB,s=t.pointA,a=t.pointB,l=e.container,d=t.render,c="c-"+t.id,p=e.primitives[c];// initialise constraint primitive if not existing
// don't render if constraint does not have two end points
return p||(p=e.primitives[c]=new PIXI.Graphics),d.visible&&t.pointA&&t.pointB?void(// render the constraint on every update, since they can change dynamically
-1===r.indexOf(l.children,p)&&l.addChild(p),p.clear(),p.beginFill(0,0),p.lineStyle(d.lineWidth,r.colorToNumber(d.strokeStyle),1),o?p.moveTo(o.position.x+s.x,o.position.y+s.y):p.moveTo(s.x,s.y),n?p.lineTo(n.position.x+a.x,n.position.y+a.y):p.lineTo(a.x,a.y),p.endFill()):void p.clear();// add to scene graph if not already there
},o.body=function(e,t){var o=e.engine,n=t.render;if(n.visible)if(n.sprite&&n.sprite.texture){var s="b-"+t.id,a=e.sprites[s],l=e.spriteContainer;// initialise body sprite if not existing
a||(a=e.sprites[s]=i(e,t)),-1===r.indexOf(l.children,a)&&l.addChild(a),a.position.x=t.position.x,a.position.y=t.position.y,a.rotation=t.angle,a.scale.x=n.sprite.xScale||1,a.scale.y=n.sprite.yScale||1}else{var c="b-"+t.id,p=e.primitives[c],m=e.container;// initialise body primitive if not existing
p||(p=e.primitives[c]=d(e,t),p.initialAngle=t.angle),-1===r.indexOf(m.children,p)&&m.addChild(p),p.position.x=t.position.x,p.position.y=t.position.y,p.rotation=t.angle-p.initialAngle}};/**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */var i=function(e,t){var i=t.render,o=i.sprite.texture,n=c(e,o),s=new PIXI.Sprite(n);return s.anchor.x=t.render.sprite.xOffset,s.anchor.y=t.render.sprite.yOffset,s},d=function(e,t){var i=t.render,o=e.options,n=new PIXI.Graphics,s=r.colorToNumber(i.fillStyle),a=r.colorToNumber(i.strokeStyle),l=r.colorToNumber(i.strokeStyle),d=r.colorToNumber("#bbb"),c=r.colorToNumber("#CD5C5C"),p;n.clear();// handle compound parts
for(var m=1<t.parts.length?1:0;m<t.parts.length;m++){p=t.parts[m],o.wireframes?(n.beginFill(0,0),n.lineStyle(1,d,1)):(n.beginFill(s,1),n.lineStyle(i.lineWidth,a,1)),n.moveTo(p.vertices[0].x-t.position.x,p.vertices[0].y-t.position.y);for(var y=1;y<p.vertices.length;y++)n.lineTo(p.vertices[y].x-t.position.x,p.vertices[y].y-t.position.y);n.lineTo(p.vertices[0].x-t.position.x,p.vertices[0].y-t.position.y),n.endFill(),(o.showAngleIndicator||o.showAxes)&&(n.beginFill(0,0),o.wireframes?n.lineStyle(1,c,1):n.lineStyle(1,l),n.moveTo(p.position.x-t.position.x,p.position.y-t.position.y),n.lineTo((p.vertices[0].x+p.vertices[p.vertices.length-1].x)/2-t.position.x,(p.vertices[0].y+p.vertices[p.vertices.length-1].y)/2-t.position.y),n.endFill())}return n},c=function(e,t){var i=e.textures[t];return i||(i=e.textures[t]=PIXI.Texture.fromImage(t)),i};/**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */})()},{"../body/Composite":2,"../core/Common":14,"../core/Events":16,"../geometry/Bounds":26,"../geometry/Vector":28}]},{},[30])(30)})}),matter_1=matter.World,matter_2=matter.Body,matter_3=matter.Bodies,matter_4=matter.Engine,matter_5=matter.Render,matter_6=matter.Constraint,things=[],engine=matter_4.create();function setGravity(e){var t=e.x,i=e.y;engine.world.gravity.x=t||0,engine.world.gravity.y=i||0}function createUI(e,t){var i=e.position,o=i.x,n=i.y,s=e.circleRadius,r=e.label,a=t&&"string"==typeof t?Sprite.from(t):createGraphics(o,n,2*s,2*s,"Circle Body"===r?s:0);return a.pivot&&(a.pivot.x=a.width/2,a.pivot.y=a.height/2),things.push({body:e,sprite:a}),a}function createGraphics(e,t,i,o,n,s){void 0===n&&(n=0),void 0===s&&(s=16777215);var r=new Graphics;return r.beginFill(s),r.drawRoundedRect(0,0,i,o,n),r.endFill(),r.x=e,r.y=t,r}var netContainer=new Container;function renderCloth(e){netContainer.removeChildren();var t=e.constraints.map(function(e){var t=e.bodyA.position,i=e.bodyB.position;return drawLine(t,i)});return netContainer.addChild.apply(netContainer,t),netContainer}function drawLine(e,t){var i=new Graphics;return i.lineStyle(1,16777215,1),i.moveTo(e.x,e.y),i.lineTo(t.x,t.y),i}function physify(e){void 0===e&&(e={});var t=e.gravity,i=void 0===t?{x:0,y:.98}:t,o=e.renderer;return setGravity(i),matter_4.run(engine),void 0!==o&&o&&matter_5.run(matter_5.create({element:document.body,engine:engine,options:{width:window.innerWidth,height:window.innerHeight,showAngleIndicator:!0}})),Ticker.shared.add(function(){things.map(function(e){var t=e.body,i=e.sprite;if(t.render.visible){var o=t.position,n=o.x,s=o.y,r=t.angle;i.rotation=r,i.x=n,i.y=s}})}),function(e){var t=e.Sprite,i=e.Text,o=e.Graphics,n=e.Container;[t,i,o,n].map(function(e){e.prototype.physify=function(n){var s=this;void 0===n&&(n={}),[t,i].includes(e)&&this.anchor.set(.5),[o].includes(e)&&(this.pivot.x=this.width/2,this.pivot.y=this.height/2),this.x+=this.width/2,this.y+=this.height/2;var r=n.shape,a=void 0===r?"rect":r,l=__rest(n,["shape"]);return this.body=function(e){return"circle"===e?matter_3.circle(s.x,s.y,s.width/2,l):matter_3.rectangle(s.x,s.y,s.width,s.height,l)}(a),this.parent&&(matter_1.add(engine.world,[this.body]),things.push({body:this.body,sprite:this})),this.body},e.prototype.bodySet=function(e,t){matter_2.set(this.body,e,t)},e.prototype.setForce=function e(t,e){void 0===t&&(t=[0,0]),void 0===e&&(e=[0,0]),matter_2.applyForce(this.body,{x:t[0],y:t[1]},{x:e[0],y:e[1]})},e.prototype.setVelocity=function e(e){void 0===e&&(e=[0,0]),matter_2.setVelocity(this.body,{x:e[0],y:e[1]})},e.prototype.constraint=function(e){var t=e.pointSelf,i=void 0===t?[0,0]:t,o=e.pointTarget,n=void 0===o?[0,0]:o;matter_1.add(engine.world,[matter_6.create({bodyA:this.body,pointA:{x:i[0],y:i[1]},pointB:{x:n[0],y:n[1]}})])}})}}export default physify;export{matter_3 as Bodies,matter_2 as Body,matter_6 as Constraint,matter_4 as Engine,matter_5 as Render,matter_1 as World,matter as __moduleExports,createUI,engine,renderCloth,setGravity,things};
//# sourceMappingURL=physify.es.min.js.map
